// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockCommander is an autogenerated mock type for the Commander type
type MockCommander struct {
	mock.Mock
}

type MockCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCommander) EXPECT() *MockCommander_Expecter {
	return &MockCommander_Expecter{mock: &_m.Mock}
}

// DecrementBy provides a mock function with given fields: ctx, key, value
func (_m *MockCommander) DecrementBy(ctx context.Context, key string, value int64) (int64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for DecrementBy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (int64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_DecrementBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecrementBy'
type MockCommander_DecrementBy_Call struct {
	*mock.Call
}

// DecrementBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockCommander_Expecter) DecrementBy(ctx interface{}, key interface{}, value interface{}) *MockCommander_DecrementBy_Call {
	return &MockCommander_DecrementBy_Call{Call: _e.mock.On("DecrementBy", ctx, key, value)}
}

func (_c *MockCommander_DecrementBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockCommander_DecrementBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockCommander_DecrementBy_Call) Return(_a0 int64, _a1 error) *MockCommander_DecrementBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_DecrementBy_Call) RunAndReturn(run func(context.Context, string, int64) (int64, error)) *MockCommander_DecrementBy_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, key
func (_m *MockCommander) Delete(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCommander_Expecter) Delete(ctx interface{}, key interface{}) *MockCommander_Delete_Call {
	return &MockCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, key)}
}

func (_c *MockCommander_Delete_Call) Run(run func(ctx context.Context, key string)) *MockCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCommander_Delete_Call) Return(_a0 int64, _a1 error) *MockCommander_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_Delete_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *MockCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Discard provides a mock function with no fields
func (_m *MockCommander) Discard() {
	_m.Called()
}

// MockCommander_Discard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Discard'
type MockCommander_Discard_Call struct {
	*mock.Call
}

// Discard is a helper method to define mock.On call
func (_e *MockCommander_Expecter) Discard() *MockCommander_Discard_Call {
	return &MockCommander_Discard_Call{Call: _e.mock.On("Discard")}
}

func (_c *MockCommander_Discard_Call) Run(run func()) *MockCommander_Discard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCommander_Discard_Call) Return() *MockCommander_Discard_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockCommander_Discard_Call) RunAndReturn(run func()) *MockCommander_Discard_Call {
	_c.Run(run)
	return _c
}

// Execute provides a mock function with given fields: ctx
func (_m *MockCommander) Execute(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockCommander_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCommander_Expecter) Execute(ctx interface{}) *MockCommander_Execute_Call {
	return &MockCommander_Execute_Call{Call: _e.mock.On("Execute", ctx)}
}

func (_c *MockCommander_Execute_Call) Run(run func(ctx context.Context)) *MockCommander_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCommander_Execute_Call) Return(_a0 error) *MockCommander_Execute_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_Execute_Call) RunAndReturn(run func(context.Context) error) *MockCommander_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *MockCommander) Expire(ctx context.Context, key string, expiration time.Duration) (bool, error) {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) (bool, error)); ok {
		return rf(ctx, key, expiration)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) bool); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration) error); ok {
		r1 = rf(ctx, key, expiration)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_Expire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expire'
type MockCommander_Expire_Call struct {
	*mock.Call
}

// Expire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockCommander_Expecter) Expire(ctx interface{}, key interface{}, expiration interface{}) *MockCommander_Expire_Call {
	return &MockCommander_Expire_Call{Call: _e.mock.On("Expire", ctx, key, expiration)}
}

func (_c *MockCommander_Expire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockCommander_Expire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_Expire_Call) Return(_a0 bool, _a1 error) *MockCommander_Expire_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_Expire_Call) RunAndReturn(run func(context.Context, string, time.Duration) (bool, error)) *MockCommander_Expire_Call {
	_c.Call.Return(run)
	return _c
}

// GetFloat provides a mock function with given fields: ctx, key
func (_m *MockCommander) GetFloat(ctx context.Context, key string) (float64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetFloat")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (float64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) float64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_GetFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFloat'
type MockCommander_GetFloat_Call struct {
	*mock.Call
}

// GetFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCommander_Expecter) GetFloat(ctx interface{}, key interface{}) *MockCommander_GetFloat_Call {
	return &MockCommander_GetFloat_Call{Call: _e.mock.On("GetFloat", ctx, key)}
}

func (_c *MockCommander_GetFloat_Call) Run(run func(ctx context.Context, key string)) *MockCommander_GetFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCommander_GetFloat_Call) Return(_a0 float64, _a1 error) *MockCommander_GetFloat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_GetFloat_Call) RunAndReturn(run func(context.Context, string) (float64, error)) *MockCommander_GetFloat_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt provides a mock function with given fields: ctx, key
func (_m *MockCommander) GetInt(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetInt")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_GetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt'
type MockCommander_GetInt_Call struct {
	*mock.Call
}

// GetInt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCommander_Expecter) GetInt(ctx interface{}, key interface{}) *MockCommander_GetInt_Call {
	return &MockCommander_GetInt_Call{Call: _e.mock.On("GetInt", ctx, key)}
}

func (_c *MockCommander_GetInt_Call) Run(run func(ctx context.Context, key string)) *MockCommander_GetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCommander_GetInt_Call) Return(_a0 int64, _a1 error) *MockCommander_GetInt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_GetInt_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *MockCommander_GetInt_Call {
	_c.Call.Return(run)
	return _c
}

// GetString provides a mock function with given fields: ctx, key
func (_m *MockCommander) GetString(ctx context.Context, key string) (string, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetString")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_GetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetString'
type MockCommander_GetString_Call struct {
	*mock.Call
}

// GetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCommander_Expecter) GetString(ctx interface{}, key interface{}) *MockCommander_GetString_Call {
	return &MockCommander_GetString_Call{Call: _e.mock.On("GetString", ctx, key)}
}

func (_c *MockCommander_GetString_Call) Run(run func(ctx context.Context, key string)) *MockCommander_GetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCommander_GetString_Call) Return(_a0 string, _a1 error) *MockCommander_GetString_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_GetString_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockCommander_GetString_Call {
	_c.Call.Return(run)
	return _c
}

// HashGetAll provides a mock function with given fields: ctx, key, out
func (_m *MockCommander) HashGetAll(ctx context.Context, key string, out interface{}) error {
	ret := _m.Called(ctx, key, out)

	if len(ret) == 0 {
		panic("no return value specified for HashGetAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, out)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_HashGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashGetAll'
type MockCommander_HashGetAll_Call struct {
	*mock.Call
}

// HashGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - out interface{}
func (_e *MockCommander_Expecter) HashGetAll(ctx interface{}, key interface{}, out interface{}) *MockCommander_HashGetAll_Call {
	return &MockCommander_HashGetAll_Call{Call: _e.mock.On("HashGetAll", ctx, key, out)}
}

func (_c *MockCommander_HashGetAll_Call) Run(run func(ctx context.Context, key string, out interface{})) *MockCommander_HashGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCommander_HashGetAll_Call) Return(_a0 error) *MockCommander_HashGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_HashGetAll_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *MockCommander_HashGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HashGetField provides a mock function with given fields: ctx, key, field, out
func (_m *MockCommander) HashGetField(ctx context.Context, key string, field string, out interface{}) error {
	ret := _m.Called(ctx, key, field, out)

	if len(ret) == 0 {
		panic("no return value specified for HashGetField")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, out)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_HashGetField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashGetField'
type MockCommander_HashGetField_Call struct {
	*mock.Call
}

// HashGetField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - out interface{}
func (_e *MockCommander_Expecter) HashGetField(ctx interface{}, key interface{}, field interface{}, out interface{}) *MockCommander_HashGetField_Call {
	return &MockCommander_HashGetField_Call{Call: _e.mock.On("HashGetField", ctx, key, field, out)}
}

func (_c *MockCommander_HashGetField_Call) Run(run func(ctx context.Context, key string, field string, out interface{})) *MockCommander_HashGetField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockCommander_HashGetField_Call) Return(_a0 error) *MockCommander_HashGetField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_HashGetField_Call) RunAndReturn(run func(context.Context, string, string, interface{}) error) *MockCommander_HashGetField_Call {
	_c.Call.Return(run)
	return _c
}

// HashSet provides a mock function with given fields: ctx, key, value
func (_m *MockCommander) HashSet(ctx context.Context, key string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for HashSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_HashSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashSet'
type MockCommander_HashSet_Call struct {
	*mock.Call
}

// HashSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *MockCommander_Expecter) HashSet(ctx interface{}, key interface{}, value interface{}) *MockCommander_HashSet_Call {
	return &MockCommander_HashSet_Call{Call: _e.mock.On("HashSet", ctx, key, value)}
}

func (_c *MockCommander_HashSet_Call) Run(run func(ctx context.Context, key string, value interface{})) *MockCommander_HashSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCommander_HashSet_Call) Return(_a0 error) *MockCommander_HashSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_HashSet_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *MockCommander_HashSet_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementBy provides a mock function with given fields: ctx, key, value
func (_m *MockCommander) IncrementBy(ctx context.Context, key string, value int64) (int64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrementBy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (int64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_IncrementBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementBy'
type MockCommander_IncrementBy_Call struct {
	*mock.Call
}

// IncrementBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockCommander_Expecter) IncrementBy(ctx interface{}, key interface{}, value interface{}) *MockCommander_IncrementBy_Call {
	return &MockCommander_IncrementBy_Call{Call: _e.mock.On("IncrementBy", ctx, key, value)}
}

func (_c *MockCommander_IncrementBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockCommander_IncrementBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockCommander_IncrementBy_Call) Return(_a0 int64, _a1 error) *MockCommander_IncrementBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_IncrementBy_Call) RunAndReturn(run func(context.Context, string, int64) (int64, error)) *MockCommander_IncrementBy_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementFloatBy provides a mock function with given fields: ctx, key, value
func (_m *MockCommander) IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrementFloatBy")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) (float64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) float64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, float64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCommander_IncrementFloatBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementFloatBy'
type MockCommander_IncrementFloatBy_Call struct {
	*mock.Call
}

// IncrementFloatBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
func (_e *MockCommander_Expecter) IncrementFloatBy(ctx interface{}, key interface{}, value interface{}) *MockCommander_IncrementFloatBy_Call {
	return &MockCommander_IncrementFloatBy_Call{Call: _e.mock.On("IncrementFloatBy", ctx, key, value)}
}

func (_c *MockCommander_IncrementFloatBy_Call) Run(run func(ctx context.Context, key string, value float64)) *MockCommander_IncrementFloatBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockCommander_IncrementFloatBy_Call) Return(_a0 float64, _a1 error) *MockCommander_IncrementFloatBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCommander_IncrementFloatBy_Call) RunAndReturn(run func(context.Context, string, float64) (float64, error)) *MockCommander_IncrementFloatBy_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloat provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloat")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloat'
type MockCommander_SetFloat_Call struct {
	*mock.Call
}

// SetFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetFloat(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetFloat_Call {
	return &MockCommander_SetFloat_Call{Call: _e.mock.On("SetFloat", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetFloat_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockCommander_SetFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetFloat_Call) Return(_a0 error) *MockCommander_SetFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetFloat_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockCommander_SetFloat_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloatIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloatIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetFloatIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloatIfExist'
type MockCommander_SetFloatIfExist_Call struct {
	*mock.Call
}

// SetFloatIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetFloatIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetFloatIfExist_Call {
	return &MockCommander_SetFloatIfExist_Call{Call: _e.mock.On("SetFloatIfExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetFloatIfExist_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockCommander_SetFloatIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetFloatIfExist_Call) Return(_a0 error) *MockCommander_SetFloatIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetFloatIfExist_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockCommander_SetFloatIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloatIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloatIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetFloatIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloatIfNotExist'
type MockCommander_SetFloatIfNotExist_Call struct {
	*mock.Call
}

// SetFloatIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetFloatIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetFloatIfNotExist_Call {
	return &MockCommander_SetFloatIfNotExist_Call{Call: _e.mock.On("SetFloatIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetFloatIfNotExist_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockCommander_SetFloatIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetFloatIfNotExist_Call) Return(_a0 error) *MockCommander_SetFloatIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetFloatIfNotExist_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockCommander_SetFloatIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetInt provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetInt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetInt'
type MockCommander_SetInt_Call struct {
	*mock.Call
}

// SetInt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetInt(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetInt_Call {
	return &MockCommander_SetInt_Call{Call: _e.mock.On("SetInt", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetInt_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockCommander_SetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetInt_Call) Return(_a0 error) *MockCommander_SetInt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetInt_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockCommander_SetInt_Call {
	_c.Call.Return(run)
	return _c
}

// SetIntIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetIntIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetIntIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIntIfExist'
type MockCommander_SetIntIfExist_Call struct {
	*mock.Call
}

// SetIntIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetIntIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetIntIfExist_Call {
	return &MockCommander_SetIntIfExist_Call{Call: _e.mock.On("SetIntIfExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetIntIfExist_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockCommander_SetIntIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetIntIfExist_Call) Return(_a0 error) *MockCommander_SetIntIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetIntIfExist_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockCommander_SetIntIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetIntIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetIntIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetIntIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIntIfNotExist'
type MockCommander_SetIntIfNotExist_Call struct {
	*mock.Call
}

// SetIntIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetIntIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetIntIfNotExist_Call {
	return &MockCommander_SetIntIfNotExist_Call{Call: _e.mock.On("SetIntIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetIntIfNotExist_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockCommander_SetIntIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetIntIfNotExist_Call) Return(_a0 error) *MockCommander_SetIntIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetIntIfNotExist_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockCommander_SetIntIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetString provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetString(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetString")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetString'
type MockCommander_SetString_Call struct {
	*mock.Call
}

// SetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetString(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetString_Call {
	return &MockCommander_SetString_Call{Call: _e.mock.On("SetString", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetString_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockCommander_SetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetString_Call) Return(_a0 error) *MockCommander_SetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetString_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockCommander_SetString_Call {
	_c.Call.Return(run)
	return _c
}

// SetStringIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetStringIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetStringIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStringIfExist'
type MockCommander_SetStringIfExist_Call struct {
	*mock.Call
}

// SetStringIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetStringIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetStringIfExist_Call {
	return &MockCommander_SetStringIfExist_Call{Call: _e.mock.On("SetStringIfExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetStringIfExist_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockCommander_SetStringIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetStringIfExist_Call) Return(_a0 error) *MockCommander_SetStringIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetStringIfExist_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockCommander_SetStringIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetStringIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockCommander) SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetStringIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCommander_SetStringIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStringIfNotExist'
type MockCommander_SetStringIfNotExist_Call struct {
	*mock.Call
}

// SetStringIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockCommander_Expecter) SetStringIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockCommander_SetStringIfNotExist_Call {
	return &MockCommander_SetStringIfNotExist_Call{Call: _e.mock.On("SetStringIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockCommander_SetStringIfNotExist_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockCommander_SetStringIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockCommander_SetStringIfNotExist_Call) Return(_a0 error) *MockCommander_SetStringIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCommander_SetStringIfNotExist_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockCommander_SetStringIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCommander creates a new instance of MockCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCommander {
	mock := &MockCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
