// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *MockClient) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockClient_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockClient_Expecter) Close() *MockClient_Close_Call {
	return &MockClient_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockClient_Close_Call) Run(run func()) *MockClient_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_Close_Call) Return(_a0 error) *MockClient_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_Close_Call) RunAndReturn(run func() error) *MockClient_Close_Call {
	_c.Call.Return(run)
	return _c
}

// DecrementBy provides a mock function with given fields: ctx, key, value
func (_m *MockClient) DecrementBy(ctx context.Context, key string, value int64) (int64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for DecrementBy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (int64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DecrementBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecrementBy'
type MockClient_DecrementBy_Call struct {
	*mock.Call
}

// DecrementBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockClient_Expecter) DecrementBy(ctx interface{}, key interface{}, value interface{}) *MockClient_DecrementBy_Call {
	return &MockClient_DecrementBy_Call{Call: _e.mock.On("DecrementBy", ctx, key, value)}
}

func (_c *MockClient_DecrementBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockClient_DecrementBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockClient_DecrementBy_Call) Return(_a0 int64, _a1 error) *MockClient_DecrementBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DecrementBy_Call) RunAndReturn(run func(context.Context, string, int64) (int64, error)) *MockClient_DecrementBy_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, key
func (_m *MockClient) Delete(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockClient_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockClient_Expecter) Delete(ctx interface{}, key interface{}) *MockClient_Delete_Call {
	return &MockClient_Delete_Call{Call: _e.mock.On("Delete", ctx, key)}
}

func (_c *MockClient_Delete_Call) Run(run func(ctx context.Context, key string)) *MockClient_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_Delete_Call) Return(_a0 int64, _a1 error) *MockClient_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Delete_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *MockClient_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Do provides a mock function with given fields: ctx, cmd, args
func (_m *MockClient) Do(ctx context.Context, cmd string, args ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, cmd)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (interface{}, error)); ok {
		return rf(ctx, cmd, args...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) interface{}); ok {
		r0 = rf(ctx, cmd, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok {
		r1 = rf(ctx, cmd, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type MockClient_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//   - ctx context.Context
//   - cmd string
//   - args ...interface{}
func (_e *MockClient_Expecter) Do(ctx interface{}, cmd interface{}, args ...interface{}) *MockClient_Do_Call {
	return &MockClient_Do_Call{Call: _e.mock.On("Do",
		append([]interface{}{ctx, cmd}, args...)...)}
}

func (_c *MockClient_Do_Call) Run(run func(ctx context.Context, cmd string, args ...interface{})) *MockClient_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockClient_Do_Call) Return(_a0 interface{}, _a1 error) *MockClient_Do_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Do_Call) RunAndReturn(run func(context.Context, string, ...interface{}) (interface{}, error)) *MockClient_Do_Call {
	_c.Call.Return(run)
	return _c
}

// DoInBatch provides a mock function with given fields: ctx, fn
func (_m *MockClient) DoInBatch(ctx context.Context, fn func(Commander) error) error {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for DoInBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(Commander) error) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DoInBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoInBatch'
type MockClient_DoInBatch_Call struct {
	*mock.Call
}

// DoInBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(Commander) error
func (_e *MockClient_Expecter) DoInBatch(ctx interface{}, fn interface{}) *MockClient_DoInBatch_Call {
	return &MockClient_DoInBatch_Call{Call: _e.mock.On("DoInBatch", ctx, fn)}
}

func (_c *MockClient_DoInBatch_Call) Run(run func(ctx context.Context, fn func(Commander) error)) *MockClient_DoInBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(Commander) error))
	})
	return _c
}

func (_c *MockClient_DoInBatch_Call) Return(_a0 error) *MockClient_DoInBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DoInBatch_Call) RunAndReturn(run func(context.Context, func(Commander) error) error) *MockClient_DoInBatch_Call {
	_c.Call.Return(run)
	return _c
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *MockClient) Expire(ctx context.Context, key string, expiration time.Duration) (bool, error) {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) (bool, error)); ok {
		return rf(ctx, key, expiration)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) bool); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration) error); ok {
		r1 = rf(ctx, key, expiration)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Expire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expire'
type MockClient_Expire_Call struct {
	*mock.Call
}

// Expire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockClient_Expecter) Expire(ctx interface{}, key interface{}, expiration interface{}) *MockClient_Expire_Call {
	return &MockClient_Expire_Call{Call: _e.mock.On("Expire", ctx, key, expiration)}
}

func (_c *MockClient_Expire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockClient_Expire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockClient_Expire_Call) Return(_a0 bool, _a1 error) *MockClient_Expire_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Expire_Call) RunAndReturn(run func(context.Context, string, time.Duration) (bool, error)) *MockClient_Expire_Call {
	_c.Call.Return(run)
	return _c
}

// GetFloat provides a mock function with given fields: ctx, key
func (_m *MockClient) GetFloat(ctx context.Context, key string) (float64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetFloat")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (float64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) float64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFloat'
type MockClient_GetFloat_Call struct {
	*mock.Call
}

// GetFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockClient_Expecter) GetFloat(ctx interface{}, key interface{}) *MockClient_GetFloat_Call {
	return &MockClient_GetFloat_Call{Call: _e.mock.On("GetFloat", ctx, key)}
}

func (_c *MockClient_GetFloat_Call) Run(run func(ctx context.Context, key string)) *MockClient_GetFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetFloat_Call) Return(_a0 float64, _a1 error) *MockClient_GetFloat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetFloat_Call) RunAndReturn(run func(context.Context, string) (float64, error)) *MockClient_GetFloat_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt provides a mock function with given fields: ctx, key
func (_m *MockClient) GetInt(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetInt")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt'
type MockClient_GetInt_Call struct {
	*mock.Call
}

// GetInt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockClient_Expecter) GetInt(ctx interface{}, key interface{}) *MockClient_GetInt_Call {
	return &MockClient_GetInt_Call{Call: _e.mock.On("GetInt", ctx, key)}
}

func (_c *MockClient_GetInt_Call) Run(run func(ctx context.Context, key string)) *MockClient_GetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetInt_Call) Return(_a0 int64, _a1 error) *MockClient_GetInt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetInt_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *MockClient_GetInt_Call {
	_c.Call.Return(run)
	return _c
}

// GetString provides a mock function with given fields: ctx, key
func (_m *MockClient) GetString(ctx context.Context, key string) (string, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetString")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetString'
type MockClient_GetString_Call struct {
	*mock.Call
}

// GetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockClient_Expecter) GetString(ctx interface{}, key interface{}) *MockClient_GetString_Call {
	return &MockClient_GetString_Call{Call: _e.mock.On("GetString", ctx, key)}
}

func (_c *MockClient_GetString_Call) Run(run func(ctx context.Context, key string)) *MockClient_GetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetString_Call) Return(_a0 string, _a1 error) *MockClient_GetString_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetString_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockClient_GetString_Call {
	_c.Call.Return(run)
	return _c
}

// HashGetAll provides a mock function with given fields: ctx, key, out
func (_m *MockClient) HashGetAll(ctx context.Context, key string, out interface{}) error {
	ret := _m.Called(ctx, key, out)

	if len(ret) == 0 {
		panic("no return value specified for HashGetAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, out)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_HashGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashGetAll'
type MockClient_HashGetAll_Call struct {
	*mock.Call
}

// HashGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - out interface{}
func (_e *MockClient_Expecter) HashGetAll(ctx interface{}, key interface{}, out interface{}) *MockClient_HashGetAll_Call {
	return &MockClient_HashGetAll_Call{Call: _e.mock.On("HashGetAll", ctx, key, out)}
}

func (_c *MockClient_HashGetAll_Call) Run(run func(ctx context.Context, key string, out interface{})) *MockClient_HashGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_HashGetAll_Call) Return(_a0 error) *MockClient_HashGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_HashGetAll_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *MockClient_HashGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HashGetField provides a mock function with given fields: ctx, key, field, out
func (_m *MockClient) HashGetField(ctx context.Context, key string, field string, out interface{}) error {
	ret := _m.Called(ctx, key, field, out)

	if len(ret) == 0 {
		panic("no return value specified for HashGetField")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, out)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_HashGetField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashGetField'
type MockClient_HashGetField_Call struct {
	*mock.Call
}

// HashGetField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - out interface{}
func (_e *MockClient_Expecter) HashGetField(ctx interface{}, key interface{}, field interface{}, out interface{}) *MockClient_HashGetField_Call {
	return &MockClient_HashGetField_Call{Call: _e.mock.On("HashGetField", ctx, key, field, out)}
}

func (_c *MockClient_HashGetField_Call) Run(run func(ctx context.Context, key string, field string, out interface{})) *MockClient_HashGetField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockClient_HashGetField_Call) Return(_a0 error) *MockClient_HashGetField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_HashGetField_Call) RunAndReturn(run func(context.Context, string, string, interface{}) error) *MockClient_HashGetField_Call {
	_c.Call.Return(run)
	return _c
}

// HashSet provides a mock function with given fields: ctx, key, value
func (_m *MockClient) HashSet(ctx context.Context, key string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for HashSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_HashSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashSet'
type MockClient_HashSet_Call struct {
	*mock.Call
}

// HashSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *MockClient_Expecter) HashSet(ctx interface{}, key interface{}, value interface{}) *MockClient_HashSet_Call {
	return &MockClient_HashSet_Call{Call: _e.mock.On("HashSet", ctx, key, value)}
}

func (_c *MockClient_HashSet_Call) Run(run func(ctx context.Context, key string, value interface{})) *MockClient_HashSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_HashSet_Call) Return(_a0 error) *MockClient_HashSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_HashSet_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *MockClient_HashSet_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementBy provides a mock function with given fields: ctx, key, value
func (_m *MockClient) IncrementBy(ctx context.Context, key string, value int64) (int64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrementBy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (int64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_IncrementBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementBy'
type MockClient_IncrementBy_Call struct {
	*mock.Call
}

// IncrementBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockClient_Expecter) IncrementBy(ctx interface{}, key interface{}, value interface{}) *MockClient_IncrementBy_Call {
	return &MockClient_IncrementBy_Call{Call: _e.mock.On("IncrementBy", ctx, key, value)}
}

func (_c *MockClient_IncrementBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockClient_IncrementBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockClient_IncrementBy_Call) Return(_a0 int64, _a1 error) *MockClient_IncrementBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_IncrementBy_Call) RunAndReturn(run func(context.Context, string, int64) (int64, error)) *MockClient_IncrementBy_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementFloatBy provides a mock function with given fields: ctx, key, value
func (_m *MockClient) IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error) {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrementFloatBy")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) (float64, error)); ok {
		return rf(ctx, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) float64); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, float64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_IncrementFloatBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementFloatBy'
type MockClient_IncrementFloatBy_Call struct {
	*mock.Call
}

// IncrementFloatBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
func (_e *MockClient_Expecter) IncrementFloatBy(ctx interface{}, key interface{}, value interface{}) *MockClient_IncrementFloatBy_Call {
	return &MockClient_IncrementFloatBy_Call{Call: _e.mock.On("IncrementFloatBy", ctx, key, value)}
}

func (_c *MockClient_IncrementFloatBy_Call) Run(run func(ctx context.Context, key string, value float64)) *MockClient_IncrementFloatBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockClient_IncrementFloatBy_Call) Return(_a0 float64, _a1 error) *MockClient_IncrementFloatBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_IncrementFloatBy_Call) RunAndReturn(run func(context.Context, string, float64) (float64, error)) *MockClient_IncrementFloatBy_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields: ctx
func (_m *MockClient) Ping(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockClient_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) Ping(ctx interface{}) *MockClient_Ping_Call {
	return &MockClient_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockClient_Ping_Call) Run(run func(ctx context.Context)) *MockClient_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_Ping_Call) Return(_a0 error) *MockClient_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_Ping_Call) RunAndReturn(run func(context.Context) error) *MockClient_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloat provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloat")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloat'
type MockClient_SetFloat_Call struct {
	*mock.Call
}

// SetFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetFloat(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetFloat_Call {
	return &MockClient_SetFloat_Call{Call: _e.mock.On("SetFloat", ctx, key, value, expiration)}
}

func (_c *MockClient_SetFloat_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockClient_SetFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetFloat_Call) Return(_a0 error) *MockClient_SetFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetFloat_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockClient_SetFloat_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloatIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloatIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetFloatIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloatIfExist'
type MockClient_SetFloatIfExist_Call struct {
	*mock.Call
}

// SetFloatIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetFloatIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetFloatIfExist_Call {
	return &MockClient_SetFloatIfExist_Call{Call: _e.mock.On("SetFloatIfExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetFloatIfExist_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockClient_SetFloatIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetFloatIfExist_Call) Return(_a0 error) *MockClient_SetFloatIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetFloatIfExist_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockClient_SetFloatIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetFloatIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetFloatIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetFloatIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFloatIfNotExist'
type MockClient_SetFloatIfNotExist_Call struct {
	*mock.Call
}

// SetFloatIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetFloatIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetFloatIfNotExist_Call {
	return &MockClient_SetFloatIfNotExist_Call{Call: _e.mock.On("SetFloatIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetFloatIfNotExist_Call) Run(run func(ctx context.Context, key string, value float64, expiration time.Duration)) *MockClient_SetFloatIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetFloatIfNotExist_Call) Return(_a0 error) *MockClient_SetFloatIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetFloatIfNotExist_Call) RunAndReturn(run func(context.Context, string, float64, time.Duration) error) *MockClient_SetFloatIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetInt provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetInt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetInt'
type MockClient_SetInt_Call struct {
	*mock.Call
}

// SetInt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetInt(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetInt_Call {
	return &MockClient_SetInt_Call{Call: _e.mock.On("SetInt", ctx, key, value, expiration)}
}

func (_c *MockClient_SetInt_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockClient_SetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetInt_Call) Return(_a0 error) *MockClient_SetInt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetInt_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockClient_SetInt_Call {
	_c.Call.Return(run)
	return _c
}

// SetIntIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetIntIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetIntIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIntIfExist'
type MockClient_SetIntIfExist_Call struct {
	*mock.Call
}

// SetIntIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetIntIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetIntIfExist_Call {
	return &MockClient_SetIntIfExist_Call{Call: _e.mock.On("SetIntIfExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetIntIfExist_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockClient_SetIntIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetIntIfExist_Call) Return(_a0 error) *MockClient_SetIntIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetIntIfExist_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockClient_SetIntIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetIntIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetIntIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetIntIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIntIfNotExist'
type MockClient_SetIntIfNotExist_Call struct {
	*mock.Call
}

// SetIntIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetIntIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetIntIfNotExist_Call {
	return &MockClient_SetIntIfNotExist_Call{Call: _e.mock.On("SetIntIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetIntIfNotExist_Call) Run(run func(ctx context.Context, key string, value int64, expiration time.Duration)) *MockClient_SetIntIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetIntIfNotExist_Call) Return(_a0 error) *MockClient_SetIntIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetIntIfNotExist_Call) RunAndReturn(run func(context.Context, string, int64, time.Duration) error) *MockClient_SetIntIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetString provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetString(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetString")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetString'
type MockClient_SetString_Call struct {
	*mock.Call
}

// SetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetString(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetString_Call {
	return &MockClient_SetString_Call{Call: _e.mock.On("SetString", ctx, key, value, expiration)}
}

func (_c *MockClient_SetString_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockClient_SetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetString_Call) Return(_a0 error) *MockClient_SetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetString_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockClient_SetString_Call {
	_c.Call.Return(run)
	return _c
}

// SetStringIfExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetStringIfExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetStringIfExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStringIfExist'
type MockClient_SetStringIfExist_Call struct {
	*mock.Call
}

// SetStringIfExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetStringIfExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetStringIfExist_Call {
	return &MockClient_SetStringIfExist_Call{Call: _e.mock.On("SetStringIfExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetStringIfExist_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockClient_SetStringIfExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetStringIfExist_Call) Return(_a0 error) *MockClient_SetStringIfExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetStringIfExist_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockClient_SetStringIfExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetStringIfNotExist provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockClient) SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetStringIfNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetStringIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStringIfNotExist'
type MockClient_SetStringIfNotExist_Call struct {
	*mock.Call
}

// SetStringIfNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expiration time.Duration
func (_e *MockClient_Expecter) SetStringIfNotExist(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockClient_SetStringIfNotExist_Call {
	return &MockClient_SetStringIfNotExist_Call{Call: _e.mock.On("SetStringIfNotExist", ctx, key, value, expiration)}
}

func (_c *MockClient_SetStringIfNotExist_Call) Run(run func(ctx context.Context, key string, value string, expiration time.Duration)) *MockClient_SetStringIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockClient_SetStringIfNotExist_Call) Return(_a0 error) *MockClient_SetStringIfNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetStringIfNotExist_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *MockClient_SetStringIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
