
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>redis: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/viebiz/lit/caching/redis/client.go (0.0%)</option>
				
				<option value="file1">github.com/viebiz/lit/caching/redis/constants.go (0.0%)</option>
				
				<option value="file2">github.com/viebiz/lit/caching/redis/errors.go (0.0%)</option>
				
				<option value="file3">github.com/viebiz/lit/caching/redis/hashes.go (0.0%)</option>
				
				<option value="file4">github.com/viebiz/lit/caching/redis/pipeline.go (0.0%)</option>
				
				<option value="file5">github.com/viebiz/lit/caching/redis/strings.go (0.0%)</option>
				
				<option value="file6">github.com/viebiz/lit/caching/redis/tracing_hook.go (0.0%)</option>
				
				<option value="file7">github.com/viebiz/lit/context.go (81.2%)</option>
				
				<option value="file8">github.com/viebiz/lit/env/env.go (69.0%)</option>
				
				<option value="file9">github.com/viebiz/lit/env/mock_Validator.go (0.0%)</option>
				
				<option value="file10">github.com/viebiz/lit/errors.go (100.0%)</option>
				
				<option value="file11">github.com/viebiz/lit/grpc_options.go (0.0%)</option>
				
				<option value="file12">github.com/viebiz/lit/grpc_server.go (51.7%)</option>
				
				<option value="file13">github.com/viebiz/lit/grpc_service_registrar.go (100.0%)</option>
				
				<option value="file14">github.com/viebiz/lit/grpc_stream_interceptor.go (0.0%)</option>
				
				<option value="file15">github.com/viebiz/lit/grpc_unary_interceptor.go (92.9%)</option>
				
				<option value="file16">github.com/viebiz/lit/grpcclient/client_conn.go (77.8%)</option>
				
				<option value="file17">github.com/viebiz/lit/grpcclient/client_interceptor.go (85.0%)</option>
				
				<option value="file18">github.com/viebiz/lit/guard/constants.go (0.0%)</option>
				
				<option value="file19">github.com/viebiz/lit/guard/errors.go (100.0%)</option>
				
				<option value="file20">github.com/viebiz/lit/guard/m2m_token_middleware.go (100.0%)</option>
				
				<option value="file21">github.com/viebiz/lit/guard/new.go (100.0%)</option>
				
				<option value="file22">github.com/viebiz/lit/guard/role_permission_handler.go (0.0%)</option>
				
				<option value="file23">github.com/viebiz/lit/guard/scope_middleware.go (100.0%)</option>
				
				<option value="file24">github.com/viebiz/lit/guard/user_token_middleware.go (92.6%)</option>
				
				<option value="file25">github.com/viebiz/lit/handler_func.go (25.0%)</option>
				
				<option value="file26">github.com/viebiz/lit/httpclient/mock_PoolOption.go (0.0%)</option>
				
				<option value="file27">github.com/viebiz/lit/httpclient/options.go (0.0%)</option>
				
				<option value="file28">github.com/viebiz/lit/httpclient/pool.go (0.0%)</option>
				
				<option value="file29">github.com/viebiz/lit/httpclient/transport.go (0.0%)</option>
				
				<option value="file30">github.com/viebiz/lit/iam/claims.go (78.0%)</option>
				
				<option value="file31">github.com/viebiz/lit/iam/context.go (0.0%)</option>
				
				<option value="file32">github.com/viebiz/lit/iam/enforcer.go (0.0%)</option>
				
				<option value="file33">github.com/viebiz/lit/iam/enforcer_adapter.go (0.0%)</option>
				
				<option value="file34">github.com/viebiz/lit/iam/enforcer_custom_keymatch.go (0.0%)</option>
				
				<option value="file35">github.com/viebiz/lit/iam/enforcer_logger.go (0.0%)</option>
				
				<option value="file36">github.com/viebiz/lit/iam/m2m_profile.go (0.0%)</option>
				
				<option value="file37">github.com/viebiz/lit/iam/mock_Enforcer.go (0.0%)</option>
				
				<option value="file38">github.com/viebiz/lit/iam/mock_ExpressionFunction.go (0.0%)</option>
				
				<option value="file39">github.com/viebiz/lit/iam/mock_HTTPClient.go (0.0%)</option>
				
				<option value="file40">github.com/viebiz/lit/iam/mock_Validator.go (0.0%)</option>
				
				<option value="file41">github.com/viebiz/lit/iam/rfc9068.go (72.4%)</option>
				
				<option value="file42">github.com/viebiz/lit/iam/testutil.go (95.8%)</option>
				
				<option value="file43">github.com/viebiz/lit/iam/user_profile.go (0.0%)</option>
				
				<option value="file44">github.com/viebiz/lit/iam/validator.go (0.0%)</option>
				
				<option value="file45">github.com/viebiz/lit/jwt/hmac.go (82.6%)</option>
				
				<option value="file46">github.com/viebiz/lit/jwt/mock_Claims.go (0.0%)</option>
				
				<option value="file47">github.com/viebiz/lit/jwt/mock_ParserOptions.go (0.0%)</option>
				
				<option value="file48">github.com/viebiz/lit/jwt/mock_Signer.go (0.0%)</option>
				
				<option value="file49">github.com/viebiz/lit/jwt/mock_SigningMethod.go (0.0%)</option>
				
				<option value="file50">github.com/viebiz/lit/jwt/mock_VerifyKey.go (0.0%)</option>
				
				<option value="file51">github.com/viebiz/lit/jwt/now.go (0.0%)</option>
				
				<option value="file52">github.com/viebiz/lit/jwt/parser.go (85.4%)</option>
				
				<option value="file53">github.com/viebiz/lit/jwt/parser_options.go (0.0%)</option>
				
				<option value="file54">github.com/viebiz/lit/jwt/registered_claims.go (66.7%)</option>
				
				<option value="file55">github.com/viebiz/lit/jwt/rsa.go (89.5%)</option>
				
				<option value="file56">github.com/viebiz/lit/jwt/testutil.go (80.0%)</option>
				
				<option value="file57">github.com/viebiz/lit/jwt/token.go (80.0%)</option>
				
				<option value="file58">github.com/viebiz/lit/jwt/types.go (66.7%)</option>
				
				<option value="file59">github.com/viebiz/lit/middleware/http/middleware_request_id.go (100.0%)</option>
				
				<option value="file60">github.com/viebiz/lit/middleware_root.go (89.3%)</option>
				
				<option value="file61">github.com/viebiz/lit/monitoring/context.go (44.4%)</option>
				
				<option value="file62">github.com/viebiz/lit/monitoring/external_service_info.go (0.0%)</option>
				
				<option value="file63">github.com/viebiz/lit/monitoring/instrument_http_incoming.go (78.8%)</option>
				
				<option value="file64">github.com/viebiz/lit/monitoring/instrument_unary_incoming_call.go (82.1%)</option>
				
				<option value="file65">github.com/viebiz/lit/monitoring/instrument_unary_outgoing_call.go (0.0%)</option>
				
				<option value="file66">github.com/viebiz/lit/monitoring/instrument_vault.go (0.0%)</option>
				
				<option value="file67">github.com/viebiz/lit/monitoring/instruments.go (9.1%)</option>
				
				<option value="file68">github.com/viebiz/lit/monitoring/log_fields.go (15.0%)</option>
				
				<option value="file69">github.com/viebiz/lit/monitoring/logger.go (60.0%)</option>
				
				<option value="file70">github.com/viebiz/lit/monitoring/metadata_carrier.go (22.2%)</option>
				
				<option value="file71">github.com/viebiz/lit/monitoring/mock_Option.go (0.0%)</option>
				
				<option value="file72">github.com/viebiz/lit/monitoring/new.go (66.7%)</option>
				
				<option value="file73">github.com/viebiz/lit/monitoring/options.go (100.0%)</option>
				
				<option value="file74">github.com/viebiz/lit/monitoring/otel/constants.go (0.0%)</option>
				
				<option value="file75">github.com/viebiz/lit/monitoring/otel/exporter.go (0.0%)</option>
				
				<option value="file76">github.com/viebiz/lit/monitoring/otel/mock_ExporterOption.go (0.0%)</option>
				
				<option value="file77">github.com/viebiz/lit/monitoring/otel/new.go (0.0%)</option>
				
				<option value="file78">github.com/viebiz/lit/monitoring/otel/options.go (0.0%)</option>
				
				<option value="file79">github.com/viebiz/lit/monitoring/test_utils.go (87.9%)</option>
				
				<option value="file80">github.com/viebiz/lit/monitoring/tracer.go (0.0%)</option>
				
				<option value="file81">github.com/viebiz/lit/monitoring/zap.go (100.0%)</option>
				
				<option value="file82">github.com/viebiz/lit/postgres/connect.go (0.0%)</option>
				
				<option value="file83">github.com/viebiz/lit/postgres/mock_Beginner.go (0.0%)</option>
				
				<option value="file84">github.com/viebiz/lit/postgres/mock_ContextBeginner.go (0.0%)</option>
				
				<option value="file85">github.com/viebiz/lit/postgres/mock_ContextExecutor.go (0.0%)</option>
				
				<option value="file86">github.com/viebiz/lit/postgres/mock_ContextTransactor.go (0.0%)</option>
				
				<option value="file87">github.com/viebiz/lit/postgres/mock_Executor.go (0.0%)</option>
				
				<option value="file88">github.com/viebiz/lit/postgres/mock_Transactor.go (0.0%)</option>
				
				<option value="file89">github.com/viebiz/lit/router.go (35.3%)</option>
				
				<option value="file90">github.com/viebiz/lit/server.go (0.0%)</option>
				
				<option value="file91">github.com/viebiz/lit/snowflake/generate.go (66.7%)</option>
				
				<option value="file92">github.com/viebiz/lit/snowflake/new.go (100.0%)</option>
				
				<option value="file93">github.com/viebiz/lit/snowflake/option.go (100.0%)</option>
				
				<option value="file94">github.com/viebiz/lit/test_helper.go (50.0%)</option>
				
				<option value="file95">github.com/viebiz/lit/vault/auth.go (0.0%)</option>
				
				<option value="file96">github.com/viebiz/lit/vault/secrets.go (0.0%)</option>
				
				<option value="file97">github.com/viebiz/lit/vault/vault.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package redis

import (
        "context"
        "crypto/tls"
        "time"

        "github.com/redis/go-redis/v9"

        pkgerrors "github.com/pkg/errors"

        "github.com/viebiz/lit/monitoring"
)

type Client interface {
        Ping(ctx context.Context) error

        Do(ctx context.Context, cmd string, args ...interface{}) (interface{}, error)

        DoInBatch(ctx context.Context, fn func(cmder Commander) error) error

        Close() error

        Delete(ctx context.Context, key string) (int64, error)

        Expire(ctx context.Context, key string, expiration time.Duration) (bool, error)

        SetString(ctx context.Context, key string, value string, expiration time.Duration) error

        SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error

        SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error

        SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error

        SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error

        SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error

        IncrementBy(ctx context.Context, key string, value int64) (int64, error)

        DecrementBy(ctx context.Context, key string, value int64) (int64, error)

        SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error

        SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error

        SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error

        IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error)

        GetString(ctx context.Context, key string) (string, error)

        GetInt(ctx context.Context, key string) (int64, error)

        GetFloat(ctx context.Context, key string) (float64, error)

        HashSet(ctx context.Context, key string, value interface{}) error

        HashGetAll(ctx context.Context, key string, out interface{}) error

        HashGetField(ctx context.Context, key string, field string, out interface{}) error
}

type redisClient struct {
        rdb redis.UniversalClient
}

// NewClient creates new redis client
//
// Examples:
//
//        client, err := NewClient("redis://user:password@localhost:6379/0?protocol=3")
func NewClient(url string) (Client, error) <span class="cov0" title="0">{
        return NewClientWithTLS(url, nil)
}</span>

// NewClientWithTLS creates new redis client with TLS configuration
func NewClientWithTLS(url string, tlsConfig *tls.Config) (Client, error) <span class="cov0" title="0">{
        // 1. Prepare Redis client configurations
        opts, err := redis.ParseURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        // 1.2. Add TLS config to Redis client options
        <span class="cov0" title="0">opts.TLSConfig = tlsConfig

        // 2. Create new Redis client
        rdb := redis.NewClient(opts)

        // 3. Setup Redis tracing hook
        info := monitoring.NewExternalServiceInfo(url)
        rdb.AddHook(newTracingHook(info))

        return redisClient{
                rdb: rdb,
        }, nil</span>
}

func (client redisClient) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if _, err := client.rdb.Ping(ctx).Result(); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (client redisClient) Do(ctx context.Context, cmd string, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        params := make([]interface{}, len(args)+1)
        params[0] = cmd
        copy(params[1:], args)

        val, err := client.rdb.Do(ctx, params...).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

// DoInBatch executes multiple Redis commands in a single call using a pipeline.
// Note: All commands are executed at once, and no results are returned until the function completes.
func (client redisClient) DoInBatch(ctx context.Context, fn func(cmder Commander) error) error <span class="cov0" title="0">{
        pipelineFunc := func(pl redis.Pipeliner) error </span><span class="cov0" title="0">{
                return fn(commander{pipeliner: pl})
        }</span>

        <span class="cov0" title="0">if _, err := client.rdb.Pipelined(ctx, pipelineFunc); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (client redisClient) Close() error <span class="cov0" title="0">{
        return client.rdb.Close()
}</span>

func (client redisClient) Delete(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        rs, err := client.rdb.Del(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (client redisClient) Expire(ctx context.Context, key string, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        rs, err := client.rdb.Expire(ctx, key, expiration).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package redis

import (
        "github.com/redis/go-redis/v9"
)

const (
        KeepTTL = redis.KeepTTL // Used to retain the existing TTL (time to live) of a key when modifying its value in Redis

        statusOK = "OK"

        setModeNone setMode = ""

        setModeNX setMode = "NX"

        setModeXX setMode = "XX"
)

type setMode string

func (s setMode) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

func (s setMode) IsValid() bool <span class="cov0" title="0">{
        return s == setModeNX || s == setModeXX
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package redis

// Error represents an error in redis package
// suppose to determine expected or unexpected error in another service
type Error string

func newError(msg string) Error <span class="cov0" title="0">{
        return Error(msg)
}</span>

func (e Error) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>

var (
        ErrFailToSetValue = newError("fail to set value")

        ErrUnsupportedInputType = newError("unsupported input type")
)
</pre>
		
		<pre class="file" id="file3" style="display: none">package redis

import (
        "context"
        "reflect"

        pkgerrors "github.com/pkg/errors"
)

// HashSet accepts values in following formats:
//
//   - HSet("myhash", map[string]interface{}{"key1": "value1", "key2": "value2"})
//
//     Playing struct With "redis" tag.
//     type MyHash struct { Key1 string `redis:"key1"`; Key2 int `redis:"key2"` }
//
//   - HSet("myhash", MyHash{"value1", "value2"}) Warn: redis-server &gt;= 4.0
//     For struct, can be a structure pointer type, we only parse the field whose tag is redis.
//     if you don't want the field to be read, you can use the `redis:"-"` flag to ignore it,
//     or you don't need to set the redis tag.
//     For the type of structure field, we only support simple data types:
//     string, int/uint(8,16,32,64), float(32,64), time.Time(to RFC3339Nano), time.Duration(to Nanoseconds ),
//     if you are other more complex or custom data types, please implement the encoding.BinaryMarshaler interface.
func (client redisClient) HashSet(ctx context.Context, key string, value interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given value input is not in Struct or map
        if reflect.TypeOf(value).Kind() != reflect.Struct &amp;&amp; reflect.TypeOf(value).Kind() != reflect.Map </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Set values to redis
        <span class="cov0" title="0">v, err := client.rdb.HSet(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        // 3. Return error if no any field set
        <span class="cov0" title="0">if v == 0 </span><span class="cov0" title="0">{
                return ErrFailToSetValue
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HashGetAll retrieves all fields and values of a Redis hash by the specified key and populates the provided pointer.
// Returns an error if the provided output is not a pointer or if any operation in Redis fails.
func (client redisClient) HashGetAll(ctx context.Context, key string, out interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given input is not pointer
        if reflect.TypeOf(out).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Get all values from redis by key
        <span class="cov0" title="0">if err := client.rdb.HGetAll(ctx, key).Scan(out); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HashGetField retrieves the value of a specific field in a Redis hash by key and field name and populates the output.
// Returns an error if the output is not a pointer or if any Redis operation fails.
func (client redisClient) HashGetField(ctx context.Context, key string, field string, out interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given input is not pointer
        if reflect.TypeOf(out).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Get a field from redis by key and field name
        <span class="cov0" title="0">if err := client.rdb.HGet(ctx, key, field).Scan(out); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package redis

import (
        "context"
        "reflect"
        "time"

        pkgerrors "github.com/pkg/errors"
        "github.com/redis/go-redis/v9"
)

type Commander interface {
        Discard()

        Execute(ctx context.Context) error

        Delete(ctx context.Context, key string) (int64, error)

        Expire(ctx context.Context, key string, expiration time.Duration) (bool, error)

        SetString(ctx context.Context, key string, value string, expiration time.Duration) error

        SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error

        SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error

        GetString(ctx context.Context, key string) (string, error)

        SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error

        SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error

        SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error

        IncrementBy(ctx context.Context, key string, value int64) (int64, error)

        DecrementBy(ctx context.Context, key string, value int64) (int64, error)

        GetInt(ctx context.Context, key string) (int64, error)

        SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error

        SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error

        SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error

        IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error)

        GetFloat(ctx context.Context, key string) (float64, error)

        HashSet(ctx context.Context, key string, value interface{}) error

        HashGetAll(ctx context.Context, key string, out interface{}) error

        HashGetField(ctx context.Context, key string, field string, out interface{}) error
}

type commander struct {
        pipeliner redis.Pipeliner
}

func (e commander) Discard() <span class="cov0" title="0">{
        e.pipeliner.Discard()
}</span>

func (e commander) Execute(ctx context.Context) error <span class="cov0" title="0">{
        if _, err := e.pipeliner.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (e commander) Delete(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        rs, err := e.pipeliner.Del(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (e commander) Expire(ctx context.Context, key string, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        rs, err := e.pipeliner.Expire(ctx, key, expiration).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (e commander) SetString(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNone)
}</span>

func (e commander) SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNX)
}</span>

func (e commander) SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeXX)
}</span>

func (e commander) GetString(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return getSingleValue[string](ctx, e.pipeliner, key)
}</span>

func (e commander) SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNone)
}</span>

func (e commander) SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNX)
}</span>

func (e commander) SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeXX)
}</span>

func (e commander) IncrementBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        rs, err := e.pipeliner.IncrBy(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (e commander) DecrementBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        rs, err := e.pipeliner.DecrBy(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (e commander) GetInt(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return getSingleValue[int64](ctx, e.pipeliner, key)
}</span>

func (e commander) SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNone)
}</span>

func (e commander) SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeNX)
}</span>

func (e commander) SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, e.pipeliner, key, value, expiration, setModeXX)
}</span>

func (e commander) IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error) <span class="cov0" title="0">{
        rs, err := e.pipeliner.IncrByFloat(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return rs, nil</span>
}

func (e commander) GetFloat(ctx context.Context, key string) (float64, error) <span class="cov0" title="0">{
        return getSingleValue[float64](ctx, e.pipeliner, key)
}</span>

func (e commander) HashSet(ctx context.Context, key string, value interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given value input is not in Struct or map
        if reflect.TypeOf(value).Kind() != reflect.Struct &amp;&amp; reflect.TypeOf(value).Kind() != reflect.Map </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Set values to redis
        <span class="cov0" title="0">v, err := e.pipeliner.HSet(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        // 3. Return error if no any field set
        <span class="cov0" title="0">if v == 0 </span><span class="cov0" title="0">{
                return ErrFailToSetValue
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (e commander) HashGetAll(ctx context.Context, key string, out interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given input is not pointer
        if reflect.TypeOf(out).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Get all values from redis by key
        <span class="cov0" title="0">if err := e.pipeliner.HGetAll(ctx, key).Scan(out); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (e commander) HashGetField(ctx context.Context, key string, field string, out interface{}) error <span class="cov0" title="0">{
        // 1. Return error if given input is not pointer
        if reflect.TypeOf(out).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return ErrUnsupportedInputType
        }</span>

        // 2. Get a field from redis by key and field name
        <span class="cov0" title="0">if err := e.pipeliner.HGet(ctx, key, field).Scan(out); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package redis

import (
        "context"
        "errors"
        "time"

        pkgerrors "github.com/pkg/errors"
        "github.com/redis/go-redis/v9"
)

func setSingleValue[T string | int64 | float64](
        ctx context.Context,
        rdb redis.Cmdable,
        key string,
        value T,
        expiration time.Duration,
        mode setMode,
) error <span class="cov0" title="0">{
        // 1. Prepare SET command arguments
        args := redis.SetArgs{
                Mode:    mode.String(),
                KeepTTL: true,
        }
        if expiration &gt; 0 </span><span class="cov0" title="0">{
                args.KeepTTL = false
                args.TTL = expiration
        }</span>

        // 2. Set value to redis
        <span class="cov0" title="0">status, err := rdb.SetArgs(ctx, key, value, args).Result()
        if err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">if mode != setModeNone &amp;&amp; status != statusOK </span><span class="cov0" title="0">{
                return ErrFailToSetValue
        }</span>

        // 3. Return result
        <span class="cov0" title="0">return nil</span>
}

func getSingleValue[T string | int64 | float64](ctx context.Context, rdb redis.Cmdable, key string) (T, error) <span class="cov0" title="0">{
        var rs T
        if err := rdb.Get(ctx, key).Scan(&amp;rs); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                        return *new(T), nil
                }</span>

                <span class="cov0" title="0">return rs, pkgerrors.WithStack(err)</span>
        }

        <span class="cov0" title="0">return rs, nil</span>
}

func (client redisClient) SetString(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNone)
}</span>

func (client redisClient) SetStringIfNotExist(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNX)
}</span>

func (client redisClient) SetStringIfExist(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeXX)
}</span>

func (client redisClient) GetString(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return getSingleValue[string](ctx, client.rdb, key)
}</span>

func (client redisClient) SetInt(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNone)
}</span>

func (client redisClient) SetIntIfNotExist(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNX)
}</span>

func (client redisClient) SetIntIfExist(ctx context.Context, key string, value int64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeXX)
}</span>

func (client redisClient) GetInt(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return getSingleValue[int64](ctx, client.rdb, key)
}</span>

func (client redisClient) IncrementBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        val, err := client.rdb.IncrBy(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

func (client redisClient) DecrementBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        val, err := client.rdb.DecrBy(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

func (client redisClient) SetFloat(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNone)
}</span>

func (client redisClient) SetFloatIfNotExist(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeNX)
}</span>

func (client redisClient) SetFloatIfExist(ctx context.Context, key string, value float64, expiration time.Duration) error <span class="cov0" title="0">{
        return setSingleValue(ctx, client.rdb, key, value, expiration, setModeXX)
}</span>

func (client redisClient) IncrementFloatBy(ctx context.Context, key string, value float64) (float64, error) <span class="cov0" title="0">{
        val, err := client.rdb.IncrByFloat(ctx, key, value).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

func (client redisClient) GetFloat(ctx context.Context, key string) (float64, error) <span class="cov0" title="0">{
        return getSingleValue[float64](ctx, client.rdb, key)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package redis

import (
        "context"
        "net"

        "github.com/redis/go-redis/extra/rediscmd/v9"
        "github.com/redis/go-redis/v9"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"

        "github.com/viebiz/lit/monitoring"
)

type tracingHook struct {
        info monitoring.ExternalServiceInfo
}

func newTracingHook(info monitoring.ExternalServiceInfo) redis.Hook <span class="cov0" title="0">{
        return tracingHook{
                info: info,
        }
}</span>

func (t tracingHook) DialHook(next redis.DialHook) redis.DialHook <span class="cov0" title="0">{
        return func(ctx context.Context, network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                var err error
                span := trace.SpanFromContext(ctx)
                span.AddEvent("Dial")
                defer func() </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                recordError(span, err)
                        }</span>
                }()

                <span class="cov0" title="0">conn, err := next(ctx, network, addr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return conn, nil</span>
        }
}

func (t tracingHook) ProcessHook(next redis.ProcessHook) redis.ProcessHook <span class="cov0" title="0">{
        return func(ctx context.Context, cmd redis.Cmder) error </span><span class="cov0" title="0">{
                var err error
                span := trace.SpanFromContext(ctx)
                span.AddEvent("Process", trace.WithAttributes(
                        attribute.String("Name", cmd.FullName()),
                        attribute.String("Statement", rediscmd.CmdString(cmd)),
                ))
                defer func() </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                recordError(span, err)
                        }</span>
                }()

                <span class="cov0" title="0">if err := next(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func (t tracingHook) ProcessPipelineHook(next redis.ProcessPipelineHook) redis.ProcessPipelineHook <span class="cov0" title="0">{
        return func(ctx context.Context, cmds []redis.Cmder) error </span><span class="cov0" title="0">{
                var err error
                summary, cmdsString := rediscmd.CmdsString(cmds)
                span := trace.SpanFromContext(ctx)
                span.AddEvent("ProcessPipeline", trace.WithAttributes(
                        attribute.String("Summary", summary),
                        attribute.String("Statement", cmdsString),
                ))
                defer func() </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                recordError(span, err)
                        }</span>
                }()

                <span class="cov0" title="0">if err := next(ctx, cmds); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func recordError(span trace.Span, err error) <span class="cov0" title="0">{
        span.AddEvent("Redis error", trace.WithAttributes(
                attribute.String("Error", err.Error()),
        ))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package lightning

import (
        "context"
        "errors"
        "mime/multipart"
        "net/http"

        "github.com/gin-gonic/gin"
)

type Context interface {
        context.Context

        Request() *http.Request

        Writer() ResponseWriter

        SetRequest(*http.Request)

        SetRequestContext(ctx context.Context) *http.Request

        SetWriter(w ResponseWriter)

        Bind(obj interface{}) error

        FormFile(name string) (*multipart.FileHeader, error)

        MultipartForm() (*multipart.Form, error)

        Set(key string, value any)

        Get(key string) (value any, exists bool)

        Status(code int)

        Header(key string, value string)

        JSON(code int, obj any)

        JSONP(code int, obj any)

        ProtoBuf(code int, obj any)

        AbortWithStatus(code int)

        AbortWithError(err error)

        Next()
}

type lightningContext struct {
        *gin.Context
}

func (c lightningContext) Request() *http.Request <span class="cov8" title="1">{
        return c.Context.Request
}</span>

func (c lightningContext) Writer() ResponseWriter <span class="cov8" title="1">{
        return c.Context.Writer
}</span>

func (c lightningContext) SetRequest(r *http.Request) <span class="cov8" title="1">{
        c.Context.Request = r
}</span>

func (c lightningContext) SetRequestContext(ctx context.Context) *http.Request <span class="cov8" title="1">{
        c.Context.Request = c.Context.Request.WithContext(ctx)
        return c.Context.Request
}</span>

func (c lightningContext) SetWriter(w ResponseWriter) <span class="cov8" title="1">{
        c.Context.Writer = w
}</span>

func (c lightningContext) AbortWithError(err error) <span class="cov8" title="1">{
        var httpErr HttpError
        if errors.As(err, &amp;httpErr) </span><span class="cov8" title="1">{
                c.Context.AbortWithStatusJSON(httpErr.Status, httpErr)
                return
        }</span>

        <span class="cov0" title="0">c.Context.AbortWithError(http.StatusInternalServerError, err)</span>
}

func (c lightningContext) Bind(obj interface{}) error <span class="cov8" title="1">{
        if err := c.Context.Bind(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Because Context.Bind does not binding URI by default
        <span class="cov8" title="1">if err := c.Context.BindUri(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package env

import (
        "fmt"
        "os"
        "strconv"
        "strings"
)

func GetAndValidate[T any](name string, validators ...Validator) (T, error) <span class="cov8" title="1">{
        var val T
        if err := parseFromString(strings.TrimSpace(os.Getenv(name)), &amp;val); err != nil </span><span class="cov0" title="0">{
                return *new(T), err
        }</span>

        <span class="cov8" title="1">for _, valid := range validators </span><span class="cov8" title="1">{
                if err := valid(name, val); err != nil </span><span class="cov8" title="1">{
                        return *new(T), err
                }</span>
        }

        <span class="cov8" title="1">return val, nil</span>
}

func parseFromString[T any](value string, dst *T) error <span class="cov8" title="1">{
        switch interface{}(*dst).(type) </span>{
        case string:<span class="cov8" title="1">
                *dst = interface{}(value).(T)

                return nil</span>
        case int:<span class="cov8" title="1">
                if value == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">parsed, err := strconv.Atoi(value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">*dst = interface{}(parsed).(T)
                return nil</span>
        case bool:<span class="cov8" title="1">
                parsed, err := strconv.ParseBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">*dst = interface{}(parsed).(T)
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("env variable must be a string, number, or boolean")</span>
        }
}

// Validator validates environment variable
type Validator func(name string, value interface{}) error

func Required() Validator <span class="cov8" title="1">{
        return func(name string, value interface{}) error </span><span class="cov8" title="1">{
                if value == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is required", name)
                }</span>

                <span class="cov8" title="1">switch value.(type) </span>{
                case string:<span class="cov8" title="1">
                        if value == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s is required", name)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

func ExpectedValues(expected ...interface{}) Validator <span class="cov0" title="0">{
        return func(name string, value interface{}) error </span><span class="cov0" title="0">{
                for _, e := range expected </span><span class="cov0" title="0">{
                        if value == e </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("%s is not expected value: %s", name, value)</span>
        }
}

func IsPositive() Validator <span class="cov8" title="1">{
        return func(name string, value interface{}) error </span><span class="cov8" title="1">{
                number, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is not a number", name)
                }</span>

                <span class="cov8" title="1">if number &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is not a positive number: %s", name, value)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package env

import mock "github.com/stretchr/testify/mock"

// MockValidator is an autogenerated mock type for the Validator type
type MockValidator struct {
        mock.Mock
}

// Execute provides a mock function with given fields: name, value
func (_m *MockValidator) Execute(name string, value interface{}) error <span class="cov0" title="0">{
        ret := _m.Called(name, value)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(name, value)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockValidator creates a new instance of MockValidator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockValidator(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockValidator <span class="cov0" title="0">{
        mock := &amp;MockValidator{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package lightning

import (
        "fmt"
        "net/http"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var (
        // HTTP errors
        ErrInternalServerError = HttpError{Status: http.StatusInternalServerError, Code: "internal_server_error", Description: "internal server error"}

        // gRPC errors
        ErrGRPCInternalServerError = status.Errorf(codes.Internal, "internal server error")
)

type HttpError struct {
        Status      int    `json:"-"`
        Code        string `json:"error"`
        Description string `json:"error_description"`
}

func (e HttpError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf(`{"error":"%s","error_description":"%s"}`, e.Code, e.Description)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package lightning

import (
        "context"
        "crypto/tls"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
)

type GRPCOption func(option *[]grpc.ServerOption)

func WithTLSConfig(tlsConfig *tls.Config) GRPCOption <span class="cov0" title="0">{
        return func(opts *[]grpc.ServerOption) </span><span class="cov0" title="0">{
                *opts = append(*opts, grpc.Creds(credentials.NewTLS(tlsConfig)))
        }</span>
}

func WithDefaultInterceptors(ctx context.Context) GRPCOption <span class="cov0" title="0">{
        return func(opts *[]grpc.ServerOption) </span><span class="cov0" title="0">{
                *opts = append(*opts,
                        grpc.ChainUnaryInterceptor(unaryServerInterceptor(ctx)),
                        //grpc.ChainStreamInterceptor(streamServerInterceptor(ctx)), // TODO: Implement later
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package lightning

import (
        "context"
        "errors"
        "fmt"
        "net"
        "os/signal"
        "syscall"

        "google.golang.org/grpc"
)

type GRPCServer struct {
        grpcServer *grpc.Server
        addr       string
}

func NewGRPCServer(ctx context.Context, addr string) (GRPCServer, error) <span class="cov0" title="0">{
        opts := []GRPCOption{
                WithDefaultInterceptors(ctx),
        }

        return NewGRPCServerWithOptions(ctx, addr, opts...)
}</span>

func NewGRPCServerWithOptions(ctx context.Context, addr string, opts ...GRPCOption) (GRPCServer, error) <span class="cov8" title="1">{
        var serverOpts []grpc.ServerOption
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;serverOpts)
        }</span>

        <span class="cov8" title="1">grpcServer := grpc.NewServer(serverOpts...)

        return GRPCServer{
                grpcServer: grpcServer,
                addr:       addr,
        }, nil</span>
}

func (srv GRPCServer) Run() error <span class="cov8" title="1">{
        // kill (no param) default send syscall.SIGTERM
        // kill -2 is syscall.SIGINT
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        return srv.start(ctx)
}</span>

func (srv GRPCServer) start(ctx context.Context) error <span class="cov8" title="1">{
        startupErr := make(chan error)

        go func() </span><span class="cov8" title="1">{
                fmt.Printf("gRPC server starting at %s\n", srv.addr)
                defer fmt.Println("gRPC server stopped")

                lis, err := net.Listen("tcp", srv.addr)
                if err != nil </span><span class="cov0" title="0">{
                        startupErr &lt;- err
                        return
                }</span>

                <span class="cov8" title="1">if err := srv.grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        startupErr &lt;- err
                }</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-startupErr:<span class="cov0" title="0">
                if !errors.Is(err, grpc.ErrServerStopped) </span><span class="cov0" title="0">{
                        return fmt.Errorf("grpc server startup error: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                srv.stop()
                return nil</span>
        }
}

func (srv GRPCServer) stop() <span class="cov0" title="0">{
        fmt.Printf("attempting to shutdown gracefully\n")
        defer fmt.Println("server shutdown successfully")

        srv.grpcServer.GracefulStop()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package lightning

import (
        "google.golang.org/grpc"
)

type ServiceRegistrar interface {
        RegisterService(desc *grpc.ServiceDesc, impl any)
}

func (srv GRPCServer) Registrar() ServiceRegistrar <span class="cov8" title="1">{
        return srv.grpcServer
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package lightning

import (
        "context"

        "google.golang.org/grpc"
)

func streamServerInterceptor(ctx context.Context) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                // TODO: implement logic

                return handler(srv, ss)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package lightning

import (
        "context"
        "fmt"
        "runtime/debug"

        "google.golang.org/grpc"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"

        "github.com/viebiz/lit/monitoring"
)

const (
        shouldLogGRPCResponse = true
)

func unaryServerInterceptor(rootCtx context.Context) grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (rs any, err error) </span><span class="cov8" title="1">{
                // Add logger to request context
                ctx = monitoring.SetInContext(ctx, monitoring.FromContext(rootCtx))

                // Start tracing for incoming unary call request
                ctx, reqMeta, endInstrumentation := monitoring.StartUnaryIncomingCall(ctx, info.FullMethod, req)
                defer func() </span><span class="cov8" title="1">{
                        if p := recover(); p != nil </span><span class="cov8" title="1">{
                                rcvErr, ok := p.(error)
                                if !ok </span><span class="cov8" title="1">{
                                        rcvErr = fmt.Errorf("%v", p)
                                }</span>

                                <span class="cov8" title="1">monitoring.FromContext(ctx).Errorf(rcvErr, "Caught a panic: %s", debug.Stack())
                                endInstrumentation(rcvErr)

                                err = ErrGRPCInternalServerError</span>
                        }
                }()

                <span class="cov8" title="1">rs, err = handler(ctx, req)

                endInstrumentation(err)

                logIncomingGRPCCall(ctx, reqMeta, rs)

                return rs, err</span>
        }
}

func parseProtoMessage(resp any) []byte <span class="cov8" title="1">{
        msg, ok := resp.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                return nil // Ignore req body if it not proto message
        }</span>

        <span class="cov8" title="1">b, err := protojson.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil // Ignore if it is invalid proto message
        }</span>

        <span class="cov8" title="1">return b</span>
}

func logIncomingGRPCCall(ctx context.Context, reqMeta monitoring.GRPCRequestMetadata, result any) <span class="cov8" title="1">{
        logFields := []monitoring.LogField{
                monitoring.Field("grpc.service_method", reqMeta.ServiceMethod),
        }

        // BodyToLog always have `{}`
        if len(reqMeta.BodyToLog) &gt; 2 </span><span class="cov8" title="1">{
                logFields = append(logFields, monitoring.Field("grpc.request_body", reqMeta.BodyToLog))
        }</span>

        <span class="cov8" title="1">if resultToLog := parseProtoMessage(result); len(resultToLog) &gt; 2 &amp;&amp; shouldLogGRPCResponse </span><span class="cov8" title="1">{
                logFields = append(logFields, monitoring.Field("grpc.response_body", parseProtoMessage(result)))
        }</span>

        <span class="cov8" title="1">monitoring.FromContext(ctx).
                With(logFields...).
                Infof("grpc.unary_incoming_call")</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package grpcclient

import (
        "context"

        pkgerrors "github.com/pkg/errors"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/viebiz/lit/monitoring"
)

// Conn defines a gRPC unary client connection interface.
type Conn interface {
        Invoke(ctx context.Context, method string, args any, reply any, opts ...grpc.CallOption) error

        NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error)
}

// NewUnauthenticatedConnection initializes and returns a new unauthenticated grpc clientConn for unary calls
func NewUnauthenticatedConnection(ctx context.Context, addr string) (Conn, error) <span class="cov8" title="1">{
        return initUnaryClient(ctx, addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
}</span>

func initUnaryClient(ctx context.Context, addr string, opts ...grpc.DialOption) (Conn, error) <span class="cov8" title="1">{
        svcInfo := monitoring.NewExternalServiceInfo(addr)

        conn, err := grpc.NewClient(addr,
                append(
                        commonUnaryClientDialOptions(svcInfo),
                        opts...,
                )...,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov8" title="1">return &amp;clientConn{
                conn: conn,
        }, nil</span>
}

type clientConn struct {
        conn *grpc.ClientConn
}

func (u clientConn) Invoke(ctx context.Context, method string, args any, reply any, opts ...grpc.CallOption) error <span class="cov8" title="1">{
        return u.conn.Invoke(ctx, method, args, reply, opts...)
}</span>

func (u clientConn) NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) <span class="cov0" title="0">{
        return u.conn.NewStream(ctx, desc, method, opts...)
}</span>

func commonUnaryClientDialOptions(svcInfo monitoring.ExternalServiceInfo) []grpc.DialOption <span class="cov8" title="1">{
        return []grpc.DialOption{
                // Explicitly disabling this as according to doc: Retry support is currently disabled by default, but will be enabled by default in the future.
                grpc.WithDisableRetry(),
                grpc.WithDefaultCallOptions(
                        externalServiceInfoOption{info: svcInfo}, // Pass service information for tracing.
                ),
                grpc.WithChainUnaryInterceptor(unaryClientInterceptor),
        }
}</span>

// externalServiceInfoOption to keeps the external service info in UnaryClient for purpose monitor
type externalServiceInfoOption struct {
        grpc.EmptyCallOption
        info monitoring.ExternalServiceInfo
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package grpcclient

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"

        "github.com/viebiz/lit/monitoring"
)

func unaryClientInterceptor(
        ctx context.Context,
        method string,
        req, reply any,
        clientConn *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
) (err error) <span class="cov8" title="1">{
        var extSvcInfo externalServiceInfoOption
        for _, opt := range opts </span><span class="cov8" title="1">{
                if v, ok := opt.(externalServiceInfoOption); ok </span><span class="cov8" title="1">{
                        extSvcInfo = v
                        continue</span>
                }
        }

        <span class="cov8" title="1">ctx, end := monitoring.StartGRPCUnaryCallSegment(ctx, extSvcInfo.info, method)
        defer func() </span><span class="cov8" title="1">{
                end(err)
        }</span>()

        <span class="cov8" title="1">logRequestBody(ctx, req)

        if err = invoker(ctx, method, req, reply, clientConn, opts...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func logRequestBody(ctx context.Context, req interface{}) <span class="cov8" title="1">{
        monitoring.FromContext(ctx).
                With(monitoring.Field("grpc.request", parseProtoRequest(req))).
                Infof("grpc.outgoing_request")
}</span>

func parseProtoRequest(req any) []byte <span class="cov8" title="1">{
        msg, ok := req.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                return nil // Ignore req body if it not proto message
        }</span>

        <span class="cov8" title="1">b, err := protojson.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil // Ignore if it is invalid proto message
        }</span>

        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package guard

type Action string

const (
        ActionRead   Action = "R"
        ActionCreate Action = "C"
        ActionUpdate Action = "U"
        ActionDelete Action = "D"
)

func (a Action) String() string <span class="cov0" title="0">{
        return string(a)
}</span>

func (a Action) IsValid() bool <span class="cov0" title="0">{
        return a == ActionRead || a == ActionCreate || a == ActionUpdate || a == ActionDelete
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package guard

import (
        "errors"
        "net/http"

        "github.com/viebiz/lit"
)

const (
        unAuthorizedKey = "unauthorized"
        forbiddenKey    = "forbidden"
)

var (
        errUserProfileNotInCtx = errors.New("user profile not in context")
        errM2MProfileNotInCtx  = errors.New("m2m profile not in context")
        errMissingAccessToken  = lightning.HttpError{Status: http.StatusUnauthorized, Code: unAuthorizedKey, Description: "Access token is required"}
        errForbidden           = lightning.HttpError{Status: http.StatusForbidden, Code: forbiddenKey, Description: "Permission denied"}
)

func unauthorizedErr(err error) lightning.HttpError <span class="cov8" title="1">{
        return lightning.HttpError{Status: http.StatusUnauthorized, Code: unAuthorizedKey, Description: err.Error()}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package guard

import (
        "github.com/viebiz/lit"
        "github.com/viebiz/lit/iam"
        "github.com/viebiz/lit/monitoring"
)

const (
        m2mIDKey = "m2m_id"
)

func (guard AuthGuard) AuthenticateM2MMiddleware() lightning.HandlerFunc <span class="cov8" title="1">{
        return func(c lightning.Context) </span><span class="cov8" title="1">{
                // 1. Get access token from request header
                tokenStr := getTokenString(c.Request())
                if tokenStr == "" </span><span class="cov8" title="1">{
                        c.AbortWithError(errMissingAccessToken)
                        return
                }</span>

                // 2. Validate access token
                <span class="cov8" title="1">tk, err := guard.validator.Validate(getTokenString(c.Request()))
                if err != nil </span><span class="cov8" title="1">{
                        responseErr(c, err)
                        return
                }</span>

                // 3. Extract M2M profile from token claims
                <span class="cov8" title="1">profile, err := iam.ExtractM2MProfileFromClaims(tk.Claims)
                if err != nil </span><span class="cov8" title="1">{
                        responseErr(c, err)
                        return
                }</span>

                // 4. Inject user information to request context
                <span class="cov8" title="1">ctx := c.Request().Context()
                ctx = iam.SetM2MProfileInContext(ctx, profile)
                ctx = monitoring.InjectField(ctx, m2mIDKey, profile.ID())
                c.SetRequestContext(ctx)

                // 5. Continue handle request
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package guard

import (
        "github.com/viebiz/lit/iam"
)

type AuthGuard struct {
        validator iam.Validator
        enforcer  iam.Enforcer
}

func New(validator iam.Validator, enforcer iam.Enforcer) AuthGuard <span class="cov8" title="1">{
        return AuthGuard{
                validator: validator,
                enforcer:  enforcer,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package guard

import (
        "errors"

        "github.com/viebiz/lit"
        "github.com/viebiz/lit/iam"
        "github.com/viebiz/lit/monitoring"
)

func (guard AuthGuard) RolePermissionHandler(handler lightning.ErrHandlerFunc, resource string, permissions Action) lightning.ErrHandlerFunc <span class="cov0" title="0">{
        return func(c lightning.Context) error </span><span class="cov0" title="0">{
                req := c.Request()
                ctx := req.Context()

                // 1. Get user profile from request context
                profile := iam.GetUserProfileFromContext(ctx)
                if profile.ID() == "" </span><span class="cov0" title="0">{
                        monitoring.FromContext(ctx).Errorf(errUserProfileNotInCtx, "Missing user profile in context")
                        return errForbidden
                }</span>

                // TODO: Multiple role not supported yet, use the first role
                <span class="cov0" title="0">var r string
                for _, role := range profile.GetRoles() </span><span class="cov0" title="0">{
                        r = role
                        break</span>
                }

                // 2. Check if profile permitted to do this action
                <span class="cov0" title="0">if err := guard.enforcer.Enforce(r, resource, permissions.String()); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, iam.ErrActionIsNotAllowed) </span><span class="cov0" title="0">{
                                return errForbidden
                        }</span>

                        <span class="cov0" title="0">return lightning.ErrInternalServerError</span>
                }

                <span class="cov0" title="0">return handler(c)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package guard

import (
        "github.com/viebiz/lit"
        "github.com/viebiz/lit/iam"
        "github.com/viebiz/lit/monitoring"
)

func (guard AuthGuard) RequiredM2MScopeMiddleware(scopes ...string) lightning.HandlerFunc <span class="cov8" title="1">{
        return func(c lightning.Context) </span><span class="cov8" title="1">{
                ctx := c.Request().Context()

                // 1. Get M2M profile from request context
                profile := iam.GetM2MProfileFromContext(ctx)
                if profile.ID() == "" </span><span class="cov8" title="1">{
                        monitoring.FromContext(ctx).Errorf(errUserProfileNotInCtx, "Missing M2M profile in context")
                        c.AbortWithError(errForbidden)
                        return
                }</span>

                // 2. Check if profile has any required scopes
                <span class="cov8" title="1">if !profile.HasAnyScope(scopes...) </span><span class="cov8" title="1">{
                        c.AbortWithError(errForbidden)
                        return
                }</span>

                // 3. Continue with the next handler
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package guard

import (
        "net/http"
        "strings"

        "github.com/viebiz/lit"
        "github.com/viebiz/lit/iam"
        "github.com/viebiz/lit/monitoring"
)

const (
        headerAuthorization       = "Authorization"
        authorizationBearerPrefix = "Bearer"
        userIDKey                 = "user_id"
        roleKey                   = "roles"
)

func (guard AuthGuard) AuthenticateUserMiddleware() lightning.HandlerFunc <span class="cov8" title="1">{
        return func(c lightning.Context) </span><span class="cov8" title="1">{
                // 1. Get access token from request header
                tokenStr := getTokenString(c.Request())
                if tokenStr == "" </span><span class="cov8" title="1">{
                        c.AbortWithError(errMissingAccessToken)
                        return
                }</span>

                // 2. Validate access token
                <span class="cov8" title="1">tk, err := guard.validator.Validate(getTokenString(c.Request()))
                if err != nil </span><span class="cov8" title="1">{
                        responseErr(c, err)
                        return
                }</span>

                // 3. Extract user profile from token claims
                <span class="cov8" title="1">profile, err := iam.ExtractUserProfileFromClaims(tk.Claims)
                if err != nil </span><span class="cov8" title="1">{
                        responseErr(c, err)
                        return
                }</span>

                // 4. Inject user information to request context
                <span class="cov8" title="1">ctx := c.Request().Context()
                ctx = iam.SetUserProfileInContext(ctx, profile)
                ctx = monitoring.InjectFields(ctx, map[string]string{
                        userIDKey: profile.ID(),
                        roleKey:   profile.GetRoleString(),
                })
                c.SetRequestContext(ctx)

                // 5. Continue handle request
                c.Next()</span>
        }
}

func getTokenString(r *http.Request) string <span class="cov8" title="1">{
        authHeaderParts := strings.Split(r.Header.Get(headerAuthorization), " ")
        if len(authHeaderParts) != 2 || authHeaderParts[0] != authorizationBearerPrefix </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return authHeaderParts[1]</span>
}

func responseErr(c lightning.Context, err error) <span class="cov8" title="1">{
        switch err.Error() </span>{
        case iam.ErrMissingRequiredClaim.Error(),
                iam.ErrTokenExpired.Error(),
                iam.ErrInvalidToken.Error():<span class="cov8" title="1">
                c.AbortWithError(unauthorizedErr(err))</span>

        case iam.ErrActionIsNotAllowed.Error():<span class="cov0" title="0">
                c.AbortWithError(errForbidden)</span>

        default:<span class="cov8" title="1">
                c.AbortWithError(lightning.ErrInternalServerError)
                monitoring.FromContext(c.Request().Context()).Errorf(err, "Got unexpected error")</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package lightning

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/viebiz/lit/monitoring"
)

// HandlerFunc represents a lightning handler function
type HandlerFunc func(ctx Context)

// ErrHandlerFunc represents a lightning handler error function
type ErrHandlerFunc func(ctx Context) error

func handleHttpError(handler ErrHandlerFunc) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                if err := handler(lightningContext{Context: c}); err != nil </span><span class="cov0" title="0">{
                        var wrapErr HttpError
                        if errors.As(err, &amp;wrapErr) </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(wrapErr.Status, wrapErr)
                                return
                        }</span>

                        // Response internal server error
                        <span class="cov0" title="0">c.AbortWithStatusJSON(http.StatusInternalServerError, ErrInternalServerError)

                        // Capture error
                        monitoring.FromContext(c.Request.Context()).Errorf(err, "Server error")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package httpclient

import (
        http "net/http"

        mock "github.com/stretchr/testify/mock"
)

// MockPoolOption is an autogenerated mock type for the PoolOption type
type MockPoolOption struct {
        mock.Mock
}

// Execute provides a mock function with given fields: _a0
func (_m *MockPoolOption) Execute(_a0 *http.Client) <span class="cov0" title="0">{
        _m.Called(_a0)
}</span>

// NewMockPoolOption creates a new instance of MockPoolOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPoolOption(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockPoolOption <span class="cov0" title="0">{
        mock := &amp;MockPoolOption{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package httpclient

import (
        "net/http"
        "time"
)

type PoolOption func(*http.Client)

func WithTimeout(timeout time.Duration) PoolOption <span class="cov0" title="0">{
        return func(c *http.Client) </span><span class="cov0" title="0">{
                c.Timeout = timeout
        }</span>
}

func WithTransport(transport http.RoundTripper) PoolOption <span class="cov0" title="0">{
        return func(c *http.Client) </span><span class="cov0" title="0">{
                c.Transport = transport
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package httpclient

import (
        "net/http"
        "time"
)

const (
        defaultTimeoutPerTry = 10 * time.Second
)

// NewSharedPool returns a new http.Client instance with customizable options, ensures
// the efficient reuse of resources by pooling HTTP connections, thereby reducing
// overhead and improving performance across multiple clients
//
// Example:
//
//        func main() {
//                sharedPool := NewSharedPool()
//
//                thirdPartyServiceClient1 := thirdPartyService.NewClient(sharedPool)
//                thirdPartyServiceClient2 := thirdPartyService.NewClient(sharedPool)
//        }
//
//        // Inside third party service
//        func (srv thirdPartyService) Send(ctx context.Context) error {
//                srv.sharedPool.Do(ctx,... ) // Implement your logic
//        }
//
// Refer https://www.loginradius.com/blog/engineering/tune-the-go-http-client-for-high-performance/
func NewSharedPool(opts ...PoolOption) *http.Client <span class="cov0" title="0">{
        cl := &amp;http.Client{
                Transport: createDefaultTransport(),
                Timeout:   defaultTimeoutPerTry,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cl)
        }</span>

        <span class="cov0" title="0">return cl</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package httpclient

import (
        "net/http"
)

const (
        defaultMaxIdleConns        = 100
        defaultMaxConnsPerHost     = 100
        defaultMaxIdleConnsPerHost = 100
)

func createDefaultTransport() *http.Transport <span class="cov0" title="0">{
        transport := http.DefaultTransport.(*http.Transport).Clone()
        transport.MaxIdleConns = defaultMaxIdleConns
        transport.MaxConnsPerHost = defaultMaxConnsPerHost
        transport.MaxIdleConnsPerHost = defaultMaxIdleConnsPerHost

        return transport
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package iam

import (
        "encoding/json"
        "fmt"
        "strconv"

        "github.com/viebiz/lit/jwt"
)

type Claims struct {
        RegisteredClaims jwt.RegisteredClaims
        ExtraClaims      map[string]interface{}
}

func (c Claims) Valid() error <span class="cov8" title="1">{
        return nil
}</span>

func (c Claims) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Initial claim map, that contains all claims in plain
        claimMap := make(map[string]interface{})

        // Add registered claims to claim map
        claimMap["iss"] = c.RegisteredClaims.Issuer

        claimMap["sub"] = c.RegisteredClaims.Subject

        if len(c.RegisteredClaims.Audience) &gt; 0 </span><span class="cov8" title="1">{
                claimMap["aud"] = c.RegisteredClaims.Audience
        }</span>

        <span class="cov8" title="1">if c.RegisteredClaims.IssuedAt != nil </span><span class="cov8" title="1">{
                claimMap["iat"] = c.RegisteredClaims.IssuedAt
        }</span>

        <span class="cov8" title="1">if c.RegisteredClaims.ExpiresAt != nil </span><span class="cov8" title="1">{
                claimMap["exp"] = c.RegisteredClaims.ExpiresAt
        }</span>

        <span class="cov8" title="1">if c.RegisteredClaims.NotBefore != nil </span><span class="cov8" title="1">{
                claimMap["nbf"] = c.RegisteredClaims.NotBefore
        }</span>

        <span class="cov8" title="1">claimMap["jti"] = c.RegisteredClaims.JTI

        claimMap["client_id"] = c.RegisteredClaims.ClientID

        // Add extra claims to claim map
        for k, v := range c.ExtraClaims </span><span class="cov8" title="1">{
                claimMap[k] = v
        }</span>

        <span class="cov8" title="1">return json.Marshal(claimMap)</span>
}

func (c *Claims) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var rawMap map[string]interface{}
        if err := json.Unmarshal(data, &amp;rawMap); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">aud, err := unmarshalAud(rawMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">iat, err := unmarshalTimestamp(rawMap, "iat")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">exp, err := unmarshalTimestamp(rawMap, "exp")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nbf, err := unmarshalTimestamp(rawMap, "nbf")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.RegisteredClaims = jwt.RegisteredClaims{
                Issuer:    unmarshalString(rawMap, "iss"),
                Subject:   unmarshalString(rawMap, "sub"),
                Audience:  aud,
                IssuedAt:  iat,
                ExpiresAt: exp,
                NotBefore: nbf,
                JTI:       unmarshalString(rawMap, "jti"),
                ClientID:  unmarshalString(rawMap, "client_id"),
        }

        // Remove registered claims from raw map
        delete(rawMap, "iss")
        delete(rawMap, "sub")
        delete(rawMap, "aud")
        delete(rawMap, "iat")
        delete(rawMap, "exp")
        delete(rawMap, "nbf")
        delete(rawMap, "jti")
        delete(rawMap, "client_id")

        if len(rawMap) &gt; 0 </span><span class="cov8" title="1">{
                c.ExtraClaims = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">for k, v := range rawMap </span><span class="cov8" title="1">{
                c.ExtraClaims[k] = v
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func unmarshalString(rawMap map[string]interface{}, key string) string <span class="cov8" title="1">{
        v, exists := rawMap[key]
        if !exists </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">rs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return rs</span>
}

func unmarshalAud(rawMap map[string]interface{}) ([]string, error) <span class="cov8" title="1">{
        aud, exists := rawMap["aud"]
        if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">switch value := aud.(type) </span>{
        case string:<span class="cov8" title="1">
                return []string{value}, nil</span>
        case []interface{}:<span class="cov8" title="1">
                var result []string
                for _, v := range value </span><span class="cov8" title="1">{
                        result = append(result, v.(string))
                }</span>

                <span class="cov8" title="1">return result, nil</span>
        case []string:<span class="cov0" title="0">
                var result []string
                for _, v := range value </span><span class="cov0" title="0">{
                        result = append(result, v)
                }</span>

                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown audience type")</span>
        }
}

func unmarshalTimestamp(rawMap map[string]interface{}, key string) (*int64, error) <span class="cov8" title="1">{
        v, exists := rawMap[key]
        if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var result int64
        var err error
        switch value := v.(type) </span>{
        case string:<span class="cov0" title="0">
                result, err = strconv.ParseInt(value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        case json.Number:<span class="cov0" title="0">
                result, err = value.Int64()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        case float64:<span class="cov8" title="1">
                result = int64(value)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown timestamp type")</span>
        }

        <span class="cov8" title="1">return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package iam

import (
        "context"
)

type contextkey string

const (
        contextKeyM2MProfile  = contextkey("m2m-profile")
        contextKeyUserProfile = contextkey("user-profile")
)

func SetM2MProfileInContext(ctx context.Context, profile M2MProfile) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, contextKeyM2MProfile, profile)
}</span>

func GetM2MProfileFromContext(ctx context.Context) M2MProfile <span class="cov0" title="0">{
        if p, ok := ctx.Value(contextKeyM2MProfile).(M2MProfile); ok </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov0" title="0">return M2MProfile{}</span>
}

func SetUserProfileInContext(ctx context.Context, profile UserProfile) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, contextKeyUserProfile, profile)
}</span>

func GetUserProfileFromContext(ctx context.Context) UserProfile <span class="cov0" title="0">{
        if p, ok := ctx.Value(contextKeyUserProfile).(UserProfile); ok </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov0" title="0">return UserProfile{}</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package iam

import (
        "context"

        "github.com/casbin/casbin/v2"
        "github.com/casbin/casbin/v2/model"
        pkgerrors "github.com/pkg/errors"

        "github.com/viebiz/lit/monitoring"
        "github.com/viebiz/lit/postgres"
)

type Enforcer interface {
        Enforce(sub, obj, act string) error
}

type enforcer struct {
        cb casbin.IEnforcer
}

type EnforcerConfig struct {
        DBConn postgres.ContextExecutor
}

func NewEnforcer(ctx context.Context, cfg EnforcerConfig) (Enforcer, error) <span class="cov0" title="0">{
        // 1. Read and parse model config
        m, err := model.NewModelFromString(authModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">adapter, err := newPostgresAdapter(cfg.DBConn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logger := enforcerLogger{
                Logger: monitoring.FromContext(ctx),
        }

        // 2. Init casbin enforcer with model
        cbEnforcer, err := casbin.NewEnforcer(m, adapter, &amp;logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">cbEnforcer.AddFunction(hasPermissionKeyMatch, hasPermission)

        return enforcer{
                cb: cbEnforcer,
        }, nil</span>
}

func (e enforcer) Enforce(sub, obj, act string) error <span class="cov0" title="0">{
        allowed, err := e.cb.Enforce(sub, obj, act)
        if err != nil </span><span class="cov0" title="0">{
                return pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                return ErrActionIsNotAllowed
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package iam

import (
        "github.com/casbin/casbin/v2/persist"
        gormadapter "github.com/casbin/gorm-adapter/v3"
        pkgerrors "github.com/pkg/errors"
        pgdriver "gorm.io/driver/postgres"
        "gorm.io/gorm"

        "github.com/viebiz/lit/postgres"
)

const (
        permissionTableName = "permissions"
)

type permission struct {
        ID    uint   `gorm:"primaryKey;autoIncrement"`
        Ptype string `gorm:"size:100;uniqueIndex:unique_index"`
        V0    string `gorm:"size:100;uniqueIndex:unique_index"`
        V1    string `gorm:"size:100;uniqueIndex:unique_index"`
        V2    string `gorm:"size:100;uniqueIndex:unique_index"`
        V3    string `gorm:"size:100;uniqueIndex:unique_index"`
        V4    string `gorm:"size:100;uniqueIndex:unique_index"`
        V5    string `gorm:"size:100;uniqueIndex:unique_index"`
}

func newPostgresAdapter(db postgres.ContextExecutor) (persist.Adapter, error) <span class="cov0" title="0">{
        gormDB, err := gorm.Open(pgdriver.New(pgdriver.Config{
                Conn: db,
        }), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">gormadapter.TurnOffAutoMigrate(gormDB)
        a, err := gormadapter.NewAdapterByDBWithCustomTable(gormDB, &amp;permission{}, permissionTableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package iam

import (
        "strings"
)

const (
        hasPermissionKeyMatch = "hasPermission"
)

func hasPermission(args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        // keyMatchFunc return false if provided action not contains required action
        keyMatchFunc := func(required, provided string) bool </span><span class="cov0" title="0">{
                for _, ch := range required </span><span class="cov0" title="0">{
                        if !strings.ContainsRune(provided, ch) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">provided := args[0].(string)
        required := args[1].(string)

        return keyMatchFunc(provided, required), nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package iam

import (
        "strings"

        "github.com/viebiz/lit/monitoring"
)

var (
        // EnforcerLog is exported variable to support log during development
        EnforcerLog = false
)

type enforcerLogger struct {
        *monitoring.Logger
}

func (i enforcerLogger) EnableLog(b bool) {<span class="cov0" title="0">}</span>

func (i enforcerLogger) IsEnabled() bool <span class="cov0" title="0">{
        return EnforcerLog
}</span>

func (i enforcerLogger) LogModel(model [][]string) <span class="cov0" title="0">{
        i.Infof("Model %v", model)
}</span>

func (i enforcerLogger) LogEnforce(matcher string, request []interface{}, result bool, explains [][]string) <span class="cov0" title="0">{
        if !i.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">i.Infof("Enforced %v, (%s), (%v), hit policy: %v", result, request, matcher, explains)</span>
}

func (i enforcerLogger) LogRole(roles []string) <span class="cov0" title="0">{
        if !i.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">i.Infof("Roles: %s", roles)</span>
}

func (i enforcerLogger) LogPolicy(policy map[string][][]string) <span class="cov0" title="0">{
        if !i.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">i.Infof("Policies: %v", policy)</span>
}

func (i enforcerLogger) LogError(err error, msg ...string) <span class="cov0" title="0">{
        if !i.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">i.Errorf(err, strings.Join(msg, ","))</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package iam

import (
        "fmt"
        "strings"
)

const (
        scopeClaimKey  string = "scope"
        scopeSeparator string = " "
)

type M2MProfile struct {
        id     string
        scopes map[string]bool
}

func NewM2MProfile(id string, scopes []string) M2MProfile <span class="cov0" title="0">{
        scopeMap := make(map[string]bool)
        for _, scope := range scopes </span><span class="cov0" title="0">{
                scopeMap[scope] = true
        }</span>

        <span class="cov0" title="0">return M2MProfile{
                id:     id,
                scopes: scopeMap,
        }</span>
}

func ExtractM2MProfileFromClaims(claims Claims) (M2MProfile, error) <span class="cov0" title="0">{
        sub := claims.RegisteredClaims.Subject

        scopeSet, err := extractScopeFromClaims(claims)
        if err != nil </span><span class="cov0" title="0">{
                return M2MProfile{}, err
        }</span>

        <span class="cov0" title="0">return M2MProfile{
                id:     sub,
                scopes: scopeSet,
        }, nil</span>
}

func (p M2MProfile) ID() string <span class="cov0" title="0">{
        return p.id
}</span>

func (p M2MProfile) GetScopes() []string <span class="cov0" title="0">{
        scopes := make([]string, 0, len(p.scopes))
        for scope := range p.scopes </span><span class="cov0" title="0">{
                scopes = append(scopes, scope)
        }</span>

        <span class="cov0" title="0">return scopes</span>
}

func (p M2MProfile) HasScope(scope string) bool <span class="cov0" title="0">{
        if match, exists := p.scopes[scope]; exists </span><span class="cov0" title="0">{
                return match
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (p M2MProfile) HasAnyScope(scopes ...string) bool <span class="cov0" title="0">{
        for _, s := range scopes </span><span class="cov0" title="0">{
                if p.HasScope(s) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func extractScopeFromClaims(claims Claims) (map[string]bool, error) <span class="cov0" title="0">{
        scopeClaim, exists := claims.ExtraClaims[scopeClaimKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMissingRequiredClaim
        }</span>

        <span class="cov0" title="0">scopes, ok := scopeClaim.(string)
        if !ok </span><span class="cov0" title="0">{
                scopes = fmt.Sprintf("%s", scopeClaim)
        }</span>

        <span class="cov0" title="0">scopeSet := make(map[string]bool)
        for _, scope := range strings.Split(scopes, scopeSeparator) </span><span class="cov0" title="0">{
                scopeSet[scope] = true
        }</span>

        <span class="cov0" title="0">return scopeSet, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package iam

import mock "github.com/stretchr/testify/mock"

// MockEnforcer is an autogenerated mock type for the Enforcer type
type MockEnforcer struct {
        mock.Mock
}

// Enforce provides a mock function with given fields: sub, obj, act
func (_m *MockEnforcer) Enforce(sub string, obj string, act string) error <span class="cov0" title="0">{
        ret := _m.Called(sub, obj, act)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enforce")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(sub, obj, act)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockEnforcer creates a new instance of MockEnforcer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEnforcer(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockEnforcer <span class="cov0" title="0">{
        mock := &amp;MockEnforcer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package iam

import mock "github.com/stretchr/testify/mock"

// MockExpressionFunction is an autogenerated mock type for the ExpressionFunction type
type MockExpressionFunction struct {
        mock.Mock
}

// Execute provides a mock function with given fields: arguments
func (_m *MockExpressionFunction) Execute(arguments ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, arguments...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov0" title="0">var r0 interface{}
        var r1 error
        if rf, ok := ret.Get(0).(func(...interface{}) (interface{}, error)); ok </span><span class="cov0" title="0">{
                return rf(arguments...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(...interface{}) interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(arguments...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(interface{})
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(arguments...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMockExpressionFunction creates a new instance of MockExpressionFunction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExpressionFunction(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockExpressionFunction <span class="cov0" title="0">{
        mock := &amp;MockExpressionFunction{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package iam

import (
        http "net/http"

        mock "github.com/stretchr/testify/mock"
)

// MockHTTPClient is an autogenerated mock type for the HTTPClient type
type MockHTTPClient struct {
        mock.Mock
}

// Do provides a mock function with given fields: req
func (_m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        ret := _m.Called(req)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Do")</span>
        }

        <span class="cov0" title="0">var r0 *http.Response
        var r1 error
        if rf, ok := ret.Get(0).(func(*http.Request) (*http.Response, error)); ok </span><span class="cov0" title="0">{
                return rf(req)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(*http.Request) *http.Response); ok </span><span class="cov0" title="0">{
                r0 = rf(req)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*http.Response)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(*http.Request) error); ok </span><span class="cov0" title="0">{
                r1 = rf(req)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMockHTTPClient creates a new instance of MockHTTPClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHTTPClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockHTTPClient <span class="cov0" title="0">{
        mock := &amp;MockHTTPClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package iam

import (
        mock "github.com/stretchr/testify/mock"
        jwt "github.com/viebiz/lit/jwt"
)

// MockValidator is an autogenerated mock type for the Validator type
type MockValidator struct {
        mock.Mock
}

// Validate provides a mock function with given fields: tokenString
func (_m *MockValidator) Validate(tokenString string) (jwt.Token[Claims], error) <span class="cov0" title="0">{
        ret := _m.Called(tokenString)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Validate")</span>
        }

        <span class="cov0" title="0">var r0 jwt.Token[Claims]
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (jwt.Token[Claims], error)); ok </span><span class="cov0" title="0">{
                return rf(tokenString)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) jwt.Token[Claims]); ok </span><span class="cov0" title="0">{
                r0 = rf(tokenString)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(jwt.Token[Claims])
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(tokenString)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMockValidator creates a new instance of MockValidator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockValidator(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockValidator <span class="cov0" title="0">{
        mock := &amp;MockValidator{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package iam

import (
        "context"
        "crypto"
        "crypto/x509"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "net/http"
        "slices"
        "strings"
        "time"

        "github.com/viebiz/lit/jwt"
)

const (
        jwkKeyUseSig = "sig" // JWK property `use` determines the JWK is for signature verification

        jwkAlgRSA = "RSA" //

        timeout = 30 * time.Second
)

var (
        rfc9068AllowTokenTypes = []string{
                "at+jwt",
                "application/at+jwt",
        }
)

// rfc9068Validator represents validator for validate oauth2 JWT
// Refer https://datatracker.ietf.org/doc/rfc9068/
type rfc9068Validator struct {
        // jwksURI contains the URL to fetch JSON Web Key set
        jwksURI string

        // issuer contains the address token issuer
        issuer string

        // audience contains the address of current service
        audience string

        // httpClient is client to call external service
        httpClient HTTPClient

        // signingKeyMap stores crypto.PublicKey
        // it will be initial at the first time run
        signingKeyMap map[string]crypto.PublicKey

        tokenParser jwt.Parser[Claims]
}

func NewRFC9068Validator(issuer, audience string, client HTTPClient) (Validator, error) <span class="cov8" title="1">{
        jwksURI := fmt.Sprintf("%s/.well-known/jwks.json", strings.TrimSuffix(issuer, "/"))
        v := rfc9068Validator{
                jwksURI:     jwksURI,
                issuer:      issuer,
                audience:    audience,
                httpClient:  client,
                tokenParser: jwt.NewParser[Claims](),
        }

        // Download signing key
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        if err := v.downloadSigningKey(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;v, nil</span>
}

// Validate validates given claims
func (v *rfc9068Validator) Validate(tokenString string) (jwt.Token[Claims], error) <span class="cov8" title="1">{
        // 1. Parse token from string
        tk, err := v.tokenParser.Parse(tokenString, v.getKeyFunc)
        if err != nil </span><span class="cov8" title="1">{
                return jwt.Token[Claims]{}, err
        }</span>

        // 2. Verify the "typ" header value
        <span class="cov8" title="1">if typ := tk.Header["typ"]; !slices.Contains(rfc9068AllowTokenTypes, typ) </span><span class="cov8" title="1">{
                return jwt.Token[Claims]{}, ErrInvalidToken
        }</span>

        // TODO: Support encrypted token

        // 3. Verify claims information
        <span class="cov8" title="1">if err := v.validateClaims(tk.Claims); err != nil </span><span class="cov8" title="1">{
                return jwt.Token[Claims]{}, err
        }</span>

        <span class="cov8" title="1">return tk, nil</span>
}

func (v *rfc9068Validator) validateClaims(c Claims) error <span class="cov8" title="1">{
        now := timeNowFunc()

        // Verify issuer claim
        if c.RegisteredClaims.Issuer == "" </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        <span class="cov8" title="1">if strings.TrimRight(c.RegisteredClaims.Issuer, "/") != v.issuer </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Verify expires_at claim
        <span class="cov8" title="1">if c.RegisteredClaims.ExpiresAt == nil </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        <span class="cov8" title="1">if exp := time.Unix(*c.RegisteredClaims.ExpiresAt, 0); now.After(exp) </span><span class="cov8" title="1">{
                return ErrTokenExpired
        }</span>

        // Verify audience claim
        <span class="cov8" title="1">if len(c.RegisteredClaims.Audience) == 0 || c.RegisteredClaims.Audience[0] == "" </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        <span class="cov8" title="1">foundAud := false
        for _, aud := range c.RegisteredClaims.Audience </span><span class="cov8" title="1">{
                if aud == v.audience </span><span class="cov8" title="1">{
                        foundAud = true
                }</span>
        }

        <span class="cov8" title="1">if !foundAud </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Verify subject claim
        <span class="cov8" title="1">if c.RegisteredClaims.Subject == "" </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Verify client_id claim
        <span class="cov8" title="1">if c.RegisteredClaims.ClientID == "" </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Verify iat claim
        <span class="cov8" title="1">if c.RegisteredClaims.IssuedAt == nil </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Verify jti claim
        <span class="cov8" title="1">if c.RegisteredClaims.JTI == "" </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *rfc9068Validator) getKeyFunc(keyID string) (crypto.PublicKey, error) <span class="cov8" title="1">{
        key, exists := v.signingKeyMap[keyID]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return key, nil</span>
}

func (v *rfc9068Validator) downloadSigningKey(ctx context.Context) error <span class="cov8" title="1">{
        keyset, err := v.fetchJWKS(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">singingKeyMap, err := v.processJWKS(ctx, keyset)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">v.signingKeyMap = singingKeyMap

        return nil</span>
}

func (v *rfc9068Validator) fetchJWKS(ctx context.Context) (JWKSet, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, v.jwksURI, nil)
        if err != nil </span><span class="cov0" title="0">{
                return JWKSet{}, err
        }</span>

        <span class="cov8" title="1">resp, err := v.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return JWKSet{}, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return JWKSet{}, fmt.Errorf("got unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var jwks JWKSet
        if err := json.NewDecoder(resp.Body).Decode(&amp;jwks); err != nil </span><span class="cov0" title="0">{
                return JWKSet{}, fmt.Errorf("could not decode jwks: %w", err)
        }</span>

        <span class="cov8" title="1">return jwks, nil</span>
}

func (v *rfc9068Validator) processJWKS(ctx context.Context, jwks JWKSet) (map[string]crypto.PublicKey, error) <span class="cov8" title="1">{
        signingKeyMap := map[string]crypto.PublicKey{}

        for _, k := range jwks.Keys </span><span class="cov8" title="1">{
                if k.Use != jwkKeyUseSig </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if k.Kty != jwkAlgRSA </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if k.KID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if len(k.X5c) &lt; 1 </span><span class="cov0" title="0">{ // If no certificate chain then skip
                        continue</span>
                }

                // pre-computing the signing key from the JWK and cert so that it does not need to be done again once cached
                <span class="cov8" title="1">pemBlock, _ := pem.Decode([]byte("-----BEGIN CERTIFICATE-----\n" + k.X5c[0] + "\n-----END CERTIFICATE-----"))
                if pemBlock == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not parse certificate PEM")
                }</span>

                <span class="cov8" title="1">cert, err := x509.ParseCertificate(pemBlock.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">signingKeyMap[k.KID] = cert.PublicKey</span>
        }

        <span class="cov8" title="1">if len(signingKeyMap) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no appropriate JWK found")
        }</span>

        <span class="cov8" title="1">return signingKeyMap, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package iam

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "math/big"
        "net/http"
        "os"
        "strings"

        "github.com/stretchr/testify/mock"
        "github.com/stretchr/testify/require"
)

func readRSAPrivateKey(t require.TestingT, path string) *rsa.PrivateKey <span class="cov8" title="1">{
        b, err := os.ReadFile(path)
        require.NoError(t, err)

        block, _ := pem.Decode(b)
        require.True(t, block != nil)

        privateKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
        require.NoError(t, err)

        rsaPrivateKey, ok := privateKey.(*rsa.PrivateKey)
        require.True(t, ok)

        return rsaPrivateKey
}</span>

func readCertificate(t require.TestingT, path string) *x509.Certificate <span class="cov8" title="1">{
        b, err := os.ReadFile(path)
        require.NoError(t, err)

        block, _ := pem.Decode(b)
        require.True(t, block != nil)

        cert, err := x509.ParseCertificate(block.Bytes)
        require.NoError(t, err)

        return cert
}</span>

func constructJWKSForTest(pubKey rsa.PublicKey, cert x509.Certificate) JWKSet <span class="cov8" title="1">{
        base64URLEncode := func(b []byte) string </span><span class="cov8" title="1">{
                encoded := base64.URLEncoding.EncodeToString(b)
                return strings.TrimRight(encoded, "=")
        }</span>

        <span class="cov8" title="1">return JWKSet{
                Keys: []JWK{
                        {
                                KID: "json-web-key-01",
                                Kty: "RSA",
                                Use: "sig",
                                N:   base64URLEncode(pubKey.N.Bytes()),
                                E:   base64URLEncode(big.NewInt(int64(pubKey.E)).Bytes()),
                                X5c: []string{
                                        base64.StdEncoding.EncodeToString(cert.Raw),
                                },
                                Alg: "RS256",
                        },
                },
        }</span>
}

type mockHTTPClient struct {
        mock.Mock
}

func (c *mockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        args := c.Called(req)

        if len(args) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Do")</span>
        }

        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package iam

import (
        "fmt"
        "slices"
        "strings"
)

const (
        roleClaimKey       string = "roles"
        permissionClaimKey string = "permissions"
)

type UserProfile struct {
        id          string
        roles       []string
        permissions []string
}

func NewUserProfile(id string, roles []string, permissions []string) UserProfile <span class="cov0" title="0">{
        return UserProfile{
                id:          id,
                roles:       roles,
                permissions: permissions,
        }
}</span>

func ExtractUserProfileFromClaims(claims Claims) (UserProfile, error) <span class="cov0" title="0">{
        sub := claims.RegisteredClaims.Subject

        roles, err := extractRolesFromClaims(claims)
        if err != nil </span><span class="cov0" title="0">{
                return UserProfile{}, err
        }</span>

        <span class="cov0" title="0">return UserProfile{
                id:    sub,
                roles: roles,
        }, nil</span>
}

func (p UserProfile) ID() string <span class="cov0" title="0">{
        return p.id
}</span>

func (p UserProfile) GetRoles() []string <span class="cov0" title="0">{
        return slices.Clone(p.roles)
}</span>

func (p UserProfile) GetPermission() []string <span class="cov0" title="0">{
        return slices.Clone(p.permissions)
}</span>

func (p UserProfile) GetRoleString() string <span class="cov0" title="0">{
        return strings.Join(p.roles, ",")
}</span>

func extractRolesFromClaims(claims Claims) ([]string, error) <span class="cov0" title="0">{
        rolesClaim, exists := claims.ExtraClaims[roleClaimKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMissingRequiredClaim
        }</span>

        <span class="cov0" title="0">switch v := rolesClaim.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.Split(v, ","), nil</span>
        case []string:<span class="cov0" title="0">
                return v, nil</span>
        case []interface{}:<span class="cov0" title="0">
                rs := make([]string, len(v))
                for idx, item := range v </span><span class="cov0" title="0">{
                        role, ok := item.(string)
                        if !ok </span><span class="cov0" title="0">{
                                role = fmt.Sprintf("%s", item)
                        }</span>

                        <span class="cov0" title="0">rs[idx] = role</span>
                }

                <span class="cov0" title="0">return rs, nil</span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidToken</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package iam

import (
        "time"

        "github.com/viebiz/lit/jwt"
)

var (
        timeNowFunc = func() time.Time <span class="cov0" title="0">{
                return time.Now().UTC()
        }</span>
)

type Validator interface {
        Validate(tokenString string) (jwt.Token[Claims], error)
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package jwt

import (
        "crypto"
        "crypto/hmac"
        "io"
)

const (
        SigningMethodNameHS256 string = "HS256"
        SigningMethodNameHS384 string = "HS384"
        SigningMethodNameHS512 string = "HS512"
)

type HMAC struct {
        Name string
        Hash crypto.Hash
}

func NewHS256() HMAC <span class="cov8" title="1">{
        return HMAC{
                Name: SigningMethodNameHS256,
                Hash: crypto.SHA256,
        }
}</span>

func NewHS384() HMAC <span class="cov8" title="1">{
        return HMAC{
                Name: SigningMethodNameHS384,
                Hash: crypto.SHA384,
        }
}</span>

func NewHS512() HMAC <span class="cov8" title="1">{
        return HMAC{
                Name: SigningMethodNameHS512,
                Hash: crypto.SHA512,
        }
}</span>

func (sm HMAC) Verify(signingString []byte, sig []byte, key VerifyKey) error <span class="cov8" title="1">{
        keyBytes, ok := key.(HMACPrivateKey)
        if !ok </span><span class="cov8" title="1">{
                return ErrInvalidKeyType
        }</span>

        <span class="cov8" title="1">if !sm.Hash.Available() </span><span class="cov0" title="0">{
                return ErrHashUnavailable
        }</span>

        <span class="cov8" title="1">hasher := hmac.New(sm.Hash.New, keyBytes)
        hasher.Write(signingString)
        if !hmac.Equal(hasher.Sum(nil), sig) </span><span class="cov0" title="0">{
                return ErrInvalidSignature
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (sm HMAC) Sign(signingString []byte, key Signer) ([]byte, error) <span class="cov8" title="1">{
        pkey, ok := key.(HMACPrivateKey)
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrInvalidKeyType
        }</span>

        <span class="cov8" title="1">if !sm.Hash.Available() </span><span class="cov0" title="0">{
                return nil, ErrHashUnavailable
        }</span>

        <span class="cov8" title="1">return pkey.Sign(nil, signingString, sm.Hash)</span>
}

func (sm HMAC) Alg() string <span class="cov0" title="0">{
        return sm.Name
}</span>

// HMACPrivateKey represents private key for HMAC signing method
type HMACPrivateKey []byte

func (h HMACPrivateKey) Sign(rand io.Reader, signingString []byte, opts crypto.SignerOpts) ([]byte, error) <span class="cov8" title="1">{
        hasher := hmac.New(opts.HashFunc().New, h)
        hasher.Write(signingString)

        return hasher.Sum(nil), nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package jwt

import mock "github.com/stretchr/testify/mock"

// MockClaims is an autogenerated mock type for the Claims type
type MockClaims struct {
        mock.Mock
}

// Valid provides a mock function with given fields:
func (_m *MockClaims) Valid() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Valid")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockClaims creates a new instance of MockClaims. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClaims(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockClaims <span class="cov0" title="0">{
        mock := &amp;MockClaims{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package jwt

import mock "github.com/stretchr/testify/mock"

// MockParserOptions is an autogenerated mock type for the ParserOptions type
type MockParserOptions struct {
        mock.Mock
}

// Execute provides a mock function with given fields: _a0
func (_m *MockParserOptions) Execute(_a0 *Parser[Claims]) <span class="cov0" title="0">{
        _m.Called(_a0)
}</span>

// NewMockParserOptions creates a new instance of MockParserOptions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockParserOptions(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockParserOptions <span class="cov0" title="0">{
        mock := &amp;MockParserOptions{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package jwt

import (
        crypto "crypto"
        io "io"

        mock "github.com/stretchr/testify/mock"
)

// MockSigner is an autogenerated mock type for the Signer type
type MockSigner struct {
        mock.Mock
}

// Sign provides a mock function with given fields: rand, digest, opts
func (_m *MockSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) <span class="cov0" title="0">{
        ret := _m.Called(rand, digest, opts)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Sign")</span>
        }

        <span class="cov0" title="0">var r0 []byte
        var r1 error
        if rf, ok := ret.Get(0).(func(io.Reader, []byte, crypto.SignerOpts) ([]byte, error)); ok </span><span class="cov0" title="0">{
                return rf(rand, digest, opts)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(io.Reader, []byte, crypto.SignerOpts) []byte); ok </span><span class="cov0" title="0">{
                r0 = rf(rand, digest, opts)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]byte)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(io.Reader, []byte, crypto.SignerOpts) error); ok </span><span class="cov0" title="0">{
                r1 = rf(rand, digest, opts)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMockSigner creates a new instance of MockSigner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSigner(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSigner <span class="cov0" title="0">{
        mock := &amp;MockSigner{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package jwt

import mock "github.com/stretchr/testify/mock"

// MockSigningMethod is an autogenerated mock type for the SigningMethod type
type MockSigningMethod struct {
        mock.Mock
}

// Alg provides a mock function with given fields:
func (_m *MockSigningMethod) Alg() string <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Alg")</span>
        }

        <span class="cov0" title="0">var r0 string
        if rf, ok := ret.Get(0).(func() string); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Sign provides a mock function with given fields: signingString, key
func (_m *MockSigningMethod) Sign(signingString []byte, key Signer) ([]byte, error) <span class="cov0" title="0">{
        ret := _m.Called(signingString, key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Sign")</span>
        }

        <span class="cov0" title="0">var r0 []byte
        var r1 error
        if rf, ok := ret.Get(0).(func([]byte, Signer) ([]byte, error)); ok </span><span class="cov0" title="0">{
                return rf(signingString, key)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func([]byte, Signer) []byte); ok </span><span class="cov0" title="0">{
                r0 = rf(signingString, key)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]byte)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func([]byte, Signer) error); ok </span><span class="cov0" title="0">{
                r1 = rf(signingString, key)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Verify provides a mock function with given fields: signingString, sig, key
func (_m *MockSigningMethod) Verify(signingString []byte, sig []byte, key VerifyKey) error <span class="cov0" title="0">{
        ret := _m.Called(signingString, sig, key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Verify")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func([]byte, []byte, VerifyKey) error); ok </span><span class="cov0" title="0">{
                r0 = rf(signingString, sig, key)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockSigningMethod creates a new instance of MockSigningMethod. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSigningMethod(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSigningMethod <span class="cov0" title="0">{
        mock := &amp;MockSigningMethod{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package jwt

import mock "github.com/stretchr/testify/mock"

// MockVerifyKey is an autogenerated mock type for the VerifyKey type
type MockVerifyKey struct {
        mock.Mock
}

// NewMockVerifyKey creates a new instance of MockVerifyKey. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockVerifyKey(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockVerifyKey <span class="cov0" title="0">{
        mock := &amp;MockVerifyKey{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package jwt

import (
        "time"
)

var (
        // timeNowFunc is a helper function for testing token claim validation by mocking the current time.
        timeNowFunc = func() time.Time <span class="cov0" title="0">{
                return time.Now().UTC()
        }</span>
)
</pre>
		
		<pre class="file" id="file52" style="display: none">package jwt

import (
        "crypto"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "strings"
)

// Parser is a generic struct for parsing and validating JWT strings.
// T represents a specific Claims type to ensure precise handling of predefined claims.
type Parser[T Claims] struct {
        signingMethods map[string]SigningMethod // Supported signing method
}

// NewParser creates a new Parser with the default signing methods and validator.
func NewParser[T Claims](opts ...ParserOptions) Parser[T] <span class="cov8" title="1">{
        p := NewDefaultParser[T]()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt((*Parser[Claims])(&amp;p))
        }</span>

        <span class="cov8" title="1">return p</span>
}

func NewDefaultParser[T Claims]() Parser[T] <span class="cov8" title="1">{
        return Parser[T]{
                signingMethods: map[string]SigningMethod{
                        SigningMethodNameRS256: NewRS256(),
                        SigningMethodNameRS384: NewRS384(),
                        SigningMethodNameRS512: NewRS512(),
                        SigningMethodNameHS256: NewHS256(),
                        SigningMethodNameHS384: NewHS384(),
                        SigningMethodNameHS512: NewHS512(),
                },
        }
}</span>

// Parse decodes the provided JWT string into a Token, verifies its signature using the provided public key.
// The public key can be determined dynamically based on the `kid` (Key ID) in the token header.
func (p Parser[T]) Parse(tokenString string, getKeyFunc func(string) (crypto.PublicKey, error)) (Token[T], error) <span class="cov8" title="1">{
        // 1. Parse JWT string to Token
        token, signingString, err := p.parseToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return Token[T]{}, err
        }</span>

        // 2. Lookup signing method
        // 2.1. Get signing algorithm in token header
        <span class="cov8" title="1">alg, exists := token.Header["alg"]
        if !exists </span><span class="cov8" title="1">{
                return Token[T]{}, ErrInvalidToken
        }</span>

        // 2.2. get signing method by name
        <span class="cov8" title="1">signingMethod, ok := p.getSigningMethod(alg)
        if !ok </span><span class="cov8" title="1">{
                return Token[T]{}, ErrSigningMethodNotSupported
        }</span>

        // 3. Verify signature by signing method
        // 3.1. Get Public/Private key for verify token,
        // Optionally, use the `kid` (Key ID) to determine which key to use for verification.
        <span class="cov8" title="1">key, err := getKeyFunc(token.Header["kid"])
        if err != nil </span><span class="cov8" title="1">{
                return Token[T]{}, err
        }</span>

        // 3.2. Verify token signature
        <span class="cov8" title="1">if err := signingMethod.Verify(signingString, token.Signature, key); err != nil </span><span class="cov8" title="1">{
                return Token[T]{}, ErrInvalidSignature
        }</span>

        // 3.3. Validate token claims
        <span class="cov8" title="1">if err := token.Claims.Valid(); err != nil </span><span class="cov8" title="1">{
                return Token[T]{}, err
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (p Parser[T]) parseToken(tokenString string) (Token[T], []byte, error) <span class="cov8" title="1">{
        parts := strings.Split(tokenString, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return Token[T]{}, nil, ErrTokenMalformed
        }</span>

        // 1.1. Decode header segment
        <span class="cov8" title="1">headerBytes, err := decodeSegment([]byte(parts[0]))
        if err != nil </span><span class="cov0" title="0">{
                return Token[T]{}, nil, err
        }</span>

        // 1.2. Decode JSON header to map
        <span class="cov8" title="1">var headerMap map[string]string
        if err := json.Unmarshal(headerBytes, &amp;headerMap); err != nil </span><span class="cov0" title="0">{
                return Token[T]{}, nil, err
        }</span>

        // 2.1. Decode payload segment
        <span class="cov8" title="1">payloadBytes, err := decodeSegment([]byte(parts[1]))
        if err != nil </span><span class="cov0" title="0">{
                return Token[T]{}, nil, err
        }</span>

        // 2.2. Decode JSON Claims
        <span class="cov8" title="1">var claims T
        if err := json.Unmarshal(payloadBytes, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return Token[T]{}, nil, err
        }</span>

        // 3.3. Decode signature
        <span class="cov8" title="1">sigBytes, err := decodeSegment([]byte(parts[2]))
        if err != nil </span><span class="cov0" title="0">{
                return Token[T]{}, nil, err
        }</span>

        <span class="cov8" title="1">signingString := fmt.Sprintf("%s.%s", parts[0], parts[1])

        return Token[T]{
                Header:    headerMap,
                Claims:    claims,
                Signature: sigBytes,
        }, []byte(signingString), nil</span>
}

func (p Parser[T]) getSigningMethod(alg string) (SigningMethod, bool) <span class="cov8" title="1">{
        method, ok := p.signingMethods[alg]
        return method, ok
}</span>

func decodeSegment(b []byte) ([]byte, error) <span class="cov8" title="1">{
        decoded := make([]byte, base64.RawURLEncoding.DecodedLen(len(b)))
        if _, err := base64.RawURLEncoding.Decode(decoded, b); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return decoded, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package jwt

type ParserOptions func(*Parser[Claims])

// WithSigningMethod add more signing method to parser
func WithSigningMethod(method SigningMethod) ParserOptions <span class="cov0" title="0">{
        return func(p *Parser[Claims]) </span><span class="cov0" title="0">{
                p.signingMethods[method.Alg()] = method
        }</span>
}

// WithSigningMethods overrides all current supported signing methods
func WithSigningMethods(signingMethods map[string]SigningMethod) ParserOptions <span class="cov0" title="0">{
        return func(p *Parser[Claims]) </span><span class="cov0" title="0">{
                p.signingMethods = signingMethods
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package jwt

import (
        "time"
)

// RegisteredClaims represents standard JWT claims
// More info: https://datatracker.ietf.org/doc/html/rfc7519#section-4.1
type RegisteredClaims struct {
        Issuer string `json:"iss,omitempty"`

        Subject string `json:"sub,omitempty"`

        Audience ClaimStrings `json:"aud,omitempty"`

        IssuedAt *int64 `json:"iat,omitempty"`

        ExpiresAt *int64 `json:"exp,omitempty"`

        NotBefore *int64 `json:"nbf,omitempty"`

        JTI string `json:"jti,omitempty"`

        ClientID string `json:"client_id,omitempty"`
}

// Valid validates time based claims "exp, iat, nbf"
// if any of the above claims are not in the token, it will still
// be considered a valid claim.
func (c RegisteredClaims) Valid() error <span class="cov8" title="1">{
        now := timeNowFunc()

        // 1. Verify the `exp` claim, it's required claims
        if c.ExpiresAt == nil </span><span class="cov0" title="0">{
                return ErrMissingRequiredClaim
        }</span>

        <span class="cov8" title="1">exp := time.Unix(*c.ExpiresAt, 0)
        if now.After(exp) </span><span class="cov8" title="1">{
                return ErrTokenExpired
        }</span>

        // 2. Verify the `iat` claim
        // If it's empty, considered as a valid claim
        <span class="cov8" title="1">if c.IssuedAt != nil </span><span class="cov8" title="1">{
                issuedAt := time.Unix(*c.IssuedAt, 0)
                if now.Before(issuedAt) </span><span class="cov0" title="0">{
                        return ErrTokenUsedBeforeIssued

                }</span>
        }

        // 3. Verify the `nbf` claim
        // If it's empty, considered as a valid claim
        <span class="cov8" title="1">if c.NotBefore != nil </span><span class="cov0" title="0">{
                notBefore := time.Unix(*c.NotBefore, 0)
                if now.Before(notBefore) </span><span class="cov0" title="0">{
                        return ErrTokenNotValidYet
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package jwt

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
)

const (
        SigningMethodNameRS256 string = "RS256"
        SigningMethodNameRS384 string = "RS384"
        SigningMethodNameRS512 string = "RS512"
)

// RSA implements the RSA family of signing methods
type RSA struct {
        Name string
        Hash crypto.Hash
}

// NewRS256 creates a new RS256 signing method struct
func NewRS256() RSA <span class="cov8" title="1">{
        return RSA{
                Name: SigningMethodNameRS256,
                Hash: crypto.SHA256,
        }
}</span>

// NewRS384 creates a new RS256 signing method struct
func NewRS384() RSA <span class="cov8" title="1">{
        return RSA{
                Name: SigningMethodNameRS384,
                Hash: crypto.SHA384,
        }
}</span>

// NewRS512 creates a new RS256 signing method struct
func NewRS512() RSA <span class="cov8" title="1">{
        return RSA{
                Name: SigningMethodNameRS512,
                Hash: crypto.SHA512,
        }
}</span>

// Sign implements token signing for the SigningMethod, that take Signer (*rsa.PrivateKey) for sign a token
func (sm RSA) Sign(signingString []byte, key Signer) ([]byte, error) <span class="cov8" title="1">{
        if _, ok := key.(*rsa.PrivateKey); !ok </span><span class="cov8" title="1">{
                return nil, ErrInvalidKeyType
        }</span>

        <span class="cov8" title="1">if !sm.Hash.Available() </span><span class="cov0" title="0">{
                return nil, ErrHashUnavailable
        }</span>

        <span class="cov8" title="1">hash := sm.Hash.New()
        hash.Write(signingString)

        return key.Sign(rand.Reader, hash.Sum(nil), sm.Hash)</span>
}

// Verify verifies the signingString with signature by provided VerifyKey, that can consider as *rsa.PublicKey
func (sm RSA) Verify(signingString []byte, sig []byte, key VerifyKey) error <span class="cov8" title="1">{
        publicKey, ok := key.(*rsa.PublicKey)
        if !ok </span><span class="cov8" title="1">{
                return ErrInvalidKeyType
        }</span>

        <span class="cov8" title="1">if !sm.Hash.Available() </span><span class="cov0" title="0">{
                return ErrHashUnavailable
        }</span>

        <span class="cov8" title="1">hash := sm.Hash.New()
        hash.Write(signingString)

        return rsa.VerifyPKCS1v15(publicKey, sm.Hash, hash.Sum(nil), sig)</span>
}

func (sm RSA) Alg() string <span class="cov8" title="1">{
        return sm.Name
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package jwt

import (
        "crypto"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "os"

        "github.com/stretchr/testify/require"
)

func parsePrivateKeyFromPEM[T crypto.PrivateKey](b []byte) (T, error) <span class="cov8" title="1">{
        bl, _ := pem.Decode(b)
        if bl == nil </span><span class="cov0" title="0">{
                return *new(T), fmt.Errorf("failed to decode PEM block")
        }</span>

        <span class="cov8" title="1">privateKey, err := x509.ParsePKCS8PrivateKey(bl.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return *new(T), err
        }</span>

        <span class="cov8" title="1">rs, ok := privateKey.(T)
        if !ok </span><span class="cov0" title="0">{
                return *new(T), fmt.Errorf("key type not match")
        }</span>

        <span class="cov8" title="1">return rs, nil</span>
}

func readKeyForTest[T crypto.Signer](t require.TestingT, path string) T <span class="cov8" title="1">{
        b, err := os.ReadFile(path)
        require.NoError(t, err)

        key, err := parsePrivateKeyFromPEM[T](b)
        require.NoError(t, err)

        return key
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package jwt

import (
        "bytes"
        "crypto"
        "encoding/base64"
        "encoding/json"
        "fmt"
)

const (
        tokenHeaderType = "JWT"
)

// Token represents a JWT Token
type Token[T Claims] struct {
        Header    map[string]string
        Claims    T
        Signature []byte

        // signingMethod specifies the algorithm used to sign the token.
        signingMethod SigningMethod
}

// NewToken creates a new Token with the specified signing method and claims
func NewToken[T Claims](method SigningMethod, claims T) Token[T] <span class="cov8" title="1">{
        tk := Token[T]{
                Header: map[string]string{
                        "typ": tokenHeaderType,
                        "alg": method.Alg(),
                },
                Claims:        claims,
                signingMethod: method,
        }

        return tk
}</span>

// SignedString creates and returns a complete, signed JWT. The token is signed
// using the SigningMethod specified in the token
func (tk Token[T]) SignedString(key crypto.Signer) (string, error) <span class="cov8" title="1">{
        msg, err := tk.signingString()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Sign the concatenated message
        <span class="cov8" title="1">sig, err := tk.signingMethod.Sign(msg, key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s.%s", msg, encodeSegment(sig)), nil</span>
}

func (tk Token[T]) signingString() ([]byte, error) <span class="cov8" title="1">{
        // Marshal the header map to JSON format
        headerBytes, err := json.Marshal(tk.Header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Marshal the payload (claims) to JSON format
        <span class="cov8" title="1">payloadBytes, err := json.Marshal(tk.Claims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Base64 encode the header and payload
        <span class="cov8" title="1">headerBase64, payloadBase64 := encodeSegment(headerBytes), encodeSegment(payloadBytes)

        return bytes.Join([][]byte{headerBase64, payloadBase64}, []byte(".")), nil</span>
}

func encodeSegment(b []byte) []byte <span class="cov8" title="1">{
        buf := make([]byte, base64.RawURLEncoding.EncodedLen(len(b)))
        base64.RawURLEncoding.Encode(buf, b)

        return buf
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package jwt

import (
        "crypto"
        "encoding/json"
        "errors"
        "fmt"
        "io"
)

// Signer represents an interface for creating digital signatures
type Signer interface {
        Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) (signature []byte, err error)
}

// VerifyKey represents a key for verify token
type VerifyKey interface{}

// ClaimStrings represents a claim's value as a slice of strings
type ClaimStrings []string

func (c *ClaimStrings) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal([]string(*c))
}</span>

func (c *ClaimStrings) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var unmarshalled interface{}
        if err := json.Unmarshal(data, &amp;unmarshalled); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch val := unmarshalled.(type) </span>{
        case string:<span class="cov8" title="1">
                if val == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">*c = []string{val}</span>
        case []string:<span class="cov0" title="0">
                *c = val</span>
        case []interface{}:<span class="cov8" title="1">
                rs := make([]string, len(val))
                for idx, el := range val </span><span class="cov8" title="1">{
                        rs[idx] = fmt.Sprintf("%v", el)
                }</span>

                <span class="cov8" title="1">*c = rs</span>
        default:<span class="cov0" title="0">
                return errors.New("audience must be a string or []string")</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package http

import (
        "github.com/viebiz/lit"
        "github.com/viebiz/lit/monitoring"
)

// RequestIDMiddleware ensures each request has a unique Request ID.
// If the Request ID is provided in the request header, it uses that;
// otherwise, it generates a new one and injects it into the request context.
func RequestIDMiddleware() lightning.HandlerFunc <span class="cov8" title="1">{
        return func(c lightning.Context) </span><span class="cov8" title="1">{
                // Get request ID from header, if it not exists, generate a new one
                requestID := c.Request().Header.Get(RequestIDHeaderName)
                if requestID == "" </span><span class="cov8" title="1">{
                        requestID = idFunc()
                }</span>

                // Inject request ID to request context
                <span class="cov8" title="1">ctx := c.Request().Context()
                ctx = monitoring.InjectField(ctx, httpRequestIDKey, requestID)

                // Update the request context
                c.SetRequestContext(ctx)

                // Add request ID to response header
                c.Header(RequestIDHeaderName, requestID)

                // Continue handle request
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package lightning

import (
        "context"
        "fmt"
        "net/http"
        "runtime/debug"

        "github.com/viebiz/lit/monitoring"
)

// rootMiddleware is a middleware function that handles tracing for incoming requests
// and recovers from any panics that may occur during request handling
func rootMiddleware(rootCtx context.Context) HandlerFunc <span class="cov8" title="1">{
        return func(c Context) </span><span class="cov8" title="1">{
                // Start tracing for the incoming request
                ctx, reqMeta, endInstrumentation := monitoring.StartIncomingRequest(monitoring.FromContext(rootCtx), c.Request())
                defer func() </span><span class="cov8" title="1">{
                        // Recover from any panic that may have occurred during request handling
                        if p := recover(); p != nil </span><span class="cov8" title="1">{
                                // Check if the panic value is an error; if not, format it as one
                                err, ok := p.(error)
                                if !ok </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("%+v", p)
                                }</span>

                                // Log the panic details and stack trace using the tracer
                                // We use c.Request.Context() as the tracing context may have been modified during the request.
                                <span class="cov8" title="1">monitoring.FromContext(c.Request().Context()).Errorf(err, "Caught a panic: %s", debug.Stack())

                                // Abort the request with a 500 Internal Server Error response.
                                c.AbortWithError(ErrInternalServerError)
                                // End the instrumentation, marking the request with a 500 status code and the error.
                                endInstrumentation(http.StatusInternalServerError, err)</span>
                        }
                }()

                // Set instrument context to request context
                <span class="cov8" title="1">c.SetRequestContext(ctx)

                // Wrap response writer to inject trace information
                c.SetWriter(wrapWriter(ctx, c.Writer()))

                // Continue handle request
                c.Next()

                // End instrumentation and log
                endInstrumentation(c.Writer().Status(), nil)

                logIncomingRequest(c, reqMeta, "http.incoming_request")</span>
        }
}

type responseRecorder struct {
        ResponseWriter

        ctx context.Context
}

func wrapWriter(ctx context.Context, w ResponseWriter) ResponseWriter <span class="cov8" title="1">{
        return &amp;responseRecorder{ResponseWriter: w, ctx: ctx}
}</span>

func (w *responseRecorder) Write(resp []byte) (n int, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        monitoring.FromContext(w.ctx).Errorf(err, "Failed to write response")
                }</span> else<span class="cov8" title="1"> {
                        monitoring.FromContext(w.ctx).Infof("Wrote %s", string(resp))
                }</span>
        }()

        <span class="cov8" title="1">return w.ResponseWriter.Write(resp)</span>
}

func logIncomingRequest(ctx Context, reqMeta monitoring.RequestMetadata, msg string) <span class="cov8" title="1">{
        logFields := []monitoring.LogField{
                monitoring.Field("http.request.method", reqMeta.Method),
                monitoring.Field("http.request.endpoint", reqMeta.Endpoint),
        }

        if len(reqMeta.ContextData) &gt; 0 </span><span class="cov0" title="0">{
                logFields = append(logFields, monitoring.Field("http.request.context_data", reqMeta.ContextData))
        }</span>

        <span class="cov8" title="1">if len(reqMeta.BodyToLog) &gt; 0 </span><span class="cov8" title="1">{
                logFields = append(logFields, monitoring.Field("http.request.body", string(reqMeta.BodyToLog)))
        }</span>

        <span class="cov8" title="1">logFields = append(logFields,
                monitoring.Field("http.response.status", ctx.Writer().Status()),
                monitoring.Field("http.response.size", ctx.Writer().Size()),
        )

        monitoring.FromContext(ctx.Request().Context()).
                With(logFields...).
                Infof(msg)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package monitoring

import (
        "context"

        "go.opentelemetry.io/otel/trace"
)

type contextKey uint8

const (
        loggerContextKey contextKey = 0
)

// SetInContext sets the logger in context
func SetInContext(ctx context.Context, logger *Logger) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerContextKey, logger)
}</span>

// FromContext gets the logger from context
func FromContext(ctx context.Context) *Logger <span class="cov8" title="1">{
        logger, ok := ctx.Value(loggerContextKey).(*Logger)
        if !ok </span><span class="cov0" title="0">{
                return NewNoopLogger()
        }</span>

        <span class="cov8" title="1">return logger</span>
}

// NewContext copies the logger from old to a new context
// Use this when you want to use a new context but copy the logger over from the original context
func NewContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        newCtx := SetInContext(context.Background(), FromContext(ctx))

        if span := trace.SpanFromContext(ctx); span.IsRecording() </span><span class="cov0" title="0">{
                newCtx = trace.ContextWithSpan(newCtx, span)
        }</span>

        <span class="cov0" title="0">return newCtx</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package monitoring

import (
        "net/url"
)

// ExternalServiceInfo holds the ext svc info
type ExternalServiceInfo struct {
        Hostname string
        Port     string
}

// NewExternalServiceInfo creates a new ExternalServiceInfo from the given url
func NewExternalServiceInfo(rawURL string) ExternalServiceInfo <span class="cov0" title="0">{
        info := ExternalServiceInfo{}

        u, err := url.Parse(rawURL)
        if err != nil || u.Host == "" </span><span class="cov0" title="0">{
                u, err = url.Parse("https://" + rawURL) // Try again as best effort.
                if err != nil </span><span class="cov0" title="0">{
                        return info
                }</span>
        }
        <span class="cov0" title="0">info.Hostname = u.Hostname()
        info.Port = u.Port()

        return info</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package monitoring

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/baggage"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/propagation"
        semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
        "go.opentelemetry.io/otel/trace"
)

const (
        httpIncomingSpanName = "http.incoming_request"

        shouldLogHTTPRequestBody = true
)

var (
        methodsWithRequestBodyMap = map[string]bool{
                http.MethodPost:  true,
                http.MethodPut:   true,
                http.MethodPatch: true,
        }
)

func StartIncomingRequest(logger *Logger, r *http.Request) (context.Context, RequestMetadata, func(int, error)) <span class="cov8" title="1">{
        logFields := []attribute.KeyValue{
                semconv.HTTPRequestMethodKey.String(r.Method),
                semconv.ServerAddressKey.String(r.Host),
                semconv.UserAgentOriginal(r.UserAgent()),
                semconv.URLFull(r.URL.Path),
                semconv.NetworkPeerAddress(r.RemoteAddr),
                semconv.NetworkProtocolVersion(r.Proto),
        }

        ctx := r.Context()

        // Collect request metadata to log
        reqMeta := RequestMetadata{
                Method:   r.Method,
                Endpoint: r.URL.Path,
        }

        // Log request body
        if bodyBytes := readRequestBody(logger, r); len(bodyBytes) &gt; 0 </span><span class="cov8" title="1">{
                logFields = append(logFields, semconv.HTTPRequestBodySize(len(bodyBytes)))
                reqMeta.BodyToLog = bodyBytes
        }</span>

        // Extract trace context from request headers
        <span class="cov8" title="1">curSpanCtx := getTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(r.Header))
        spanCtx := trace.SpanContextFromContext(curSpanCtx)

        bags := baggage.FromContext(curSpanCtx)
        reqMeta.ContextData = make([]string, bags.Len())
        for idx, kv := range bags.Members() </span><span class="cov8" title="1">{
                reqMeta.ContextData[idx] = kv.String()
        }</span>

        // Add baggage to the context
        <span class="cov8" title="1">ctx = baggage.ContextWithBaggage(ctx, bags)
        ctx, span := getTracer().Start(trace.ContextWithRemoteSpanContext(ctx, spanCtx), httpIncomingSpanName,
                trace.WithSpanKind(trace.SpanKindServer),
                trace.WithAttributes(logFields...),
        )

        return injectTracingInfo(SetInContext(ctx, logger), span.SpanContext()),
                reqMeta,
                func(status int, err error) </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                span.SetStatus(codes.Error, err.Error())
                                span.RecordError(err)
                        }</span>

                        <span class="cov8" title="1">span.SetAttributes(semconv.HTTPResponseStatusCode(status))
                        span.End(trace.WithTimestamp(timeNowFunc().UTC()))</span>
                }
}

type RequestMetadata struct {
        Method      string
        Endpoint    string
        BodyToLog   []byte
        ContextData []string
}

func readRequestBody(logger *Logger, r *http.Request) []byte <span class="cov8" title="1">{
        if r.ContentLength == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if !(shouldLogHTTPRequestBody &amp;&amp; methodsWithRequestBodyMap[r.Method]) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if r.ContentLength &gt; 10_000 </span><span class="cov0" title="0">{
                // Quite unlikely that request body JSON payload will be more than this. This max limit already gives ~500 lines
                // of JSON payload.
                return nil
        }</span>

        <span class="cov8" title="1">bodyBytes := bytes.NewBuffer(nil)
        if _, err := bodyBytes.ReadFrom(r.Body); err != nil </span><span class="cov0" title="0">{
                logger.Errorf(err, "failed to read request body")
        }</span>

        <span class="cov8" title="1">if !json.Valid(bodyBytes.Bytes()) </span><span class="cov0" title="0">{ // We don't care about invalid JSON for logging
                return nil
        }</span>

        // Rewind request body, that allows read again
        <span class="cov8" title="1">r.Body = io.NopCloser(bodyBytes)

        // TODO: redact request body
        return bodyBytes.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package monitoring

import (
        "context"
        "strings"
        "time"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/baggage"
        "go.opentelemetry.io/otel/codes"
        semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

const (
        unaryIncomingSpanName = "grpc.unary_incoming_call"

        shouldLogUnaryRequestBody = true
)

var (
        timeNowFunc = time.Now
)

func StartUnaryIncomingCall(ctx context.Context, fullMethod string, req any) (context.Context, GRPCRequestMetadata, func(error)) <span class="cov8" title="1">{
        // Init log fields
        logFields := []attribute.KeyValue{
                semconv.RPCSystemGRPC,
        }

        if pr, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                logFields = append(logFields,
                        semconv.NetworkPeerAddress(pr.Addr.String()),
                        semconv.NetworkTransportKey.String(pr.Addr.Network()),
                )
        }</span>

        <span class="cov8" title="1">if svc, m := extractFullMethod(fullMethod); m != "" </span><span class="cov8" title="1">{
                logFields = append(logFields,
                        semconv.RPCService(svc),
                        semconv.RPCMethod(m),
                )
        }</span>

        <span class="cov8" title="1">reqMeta := GRPCRequestMetadata{
                ServiceMethod: fullMethod,
        }

        // Log request body
        if shouldLogUnaryRequestBody </span><span class="cov8" title="1">{
                reqMeta.BodyToLog = serializeProtoRequest(req)
        }</span>

        // Extract metadata from incoming context
        <span class="cov8" title="1">md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                md = metadata.MD{}
        }</span> else<span class="cov8" title="1"> {
                md = md.Copy() // because it's not safe to modify
        }</span>

        // Extract span context from metadata
        <span class="cov8" title="1">curSpanCtx := getTextMapPropagator().Extract(ctx, mdCarrier(md))
        spanCtx := trace.SpanContextFromContext(curSpanCtx)
        bags := baggage.FromContext(curSpanCtx)
        reqMeta.ContextData = make([]string, bags.Len())
        for idx, kv := range bags.Members() </span><span class="cov8" title="1">{
                reqMeta.ContextData[idx] = kv.String()
        }</span>

        // Add baggage to the context (ensures the baggage is passed along with the context)
        <span class="cov8" title="1">ctx = baggage.ContextWithBaggage(ctx, bags)
        ctx, span := getTracer().Start(trace.ContextWithRemoteSpanContext(ctx, spanCtx), unaryIncomingSpanName,
                trace.WithSpanKind(trace.SpanKindServer),
                trace.WithAttributes(logFields...),
        )

        return injectTracingInfo(ctx, span.SpanContext()),
                reqMeta,
                func(err error) </span><span class="cov8" title="1">{
                        if err == nil </span><span class="cov8" title="1">{
                                span.SetStatus(codes.Ok, "")
                                span.SetAttributes(semconv.RPCGRPCStatusCodeOk)
                        }</span> else<span class="cov0" title="0"> {
                                span.SetStatus(codes.Error, err.Error())
                                errStatus := status.Convert(err)
                                span.SetAttributes(semconv.RPCGRPCStatusCodeKey.Int(int(errStatus.Code())))
                        }</span>

                        <span class="cov8" title="1">span.End(trace.WithTimestamp(timeNowFunc().UTC()))</span>
                }
}

type GRPCRequestMetadata struct {
        ServiceMethod string
        BodyToLog     []byte
        ContextData   []string
}

// extractFullMethod extracts full method /weather.WeatherService/GetWeatherInfo
func extractFullMethod(fullMethod string) (string, string) <span class="cov8" title="1">{
        parts := strings.Split(fullMethod, "/")
        if len(parts) == 3 </span><span class="cov8" title="1">{
                return parts[1], parts[2]
        }</span>

        <span class="cov0" title="0">return parts[0], ""</span>
}

// serializeProtoRequest converts protobuf request to JSON bytes
// output may be unstable due to known issues: https://github.com/golang/protobuf/issues/1121
func serializeProtoRequest(req any) []byte <span class="cov8" title="1">{
        msg, ok := req.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                return nil // Ignore req body if it not proto message
        }</span>

        <span class="cov8" title="1">b, err := protojson.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil // Ignore if it is invalid proto message
        }</span>

        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package monitoring

import (
        "context"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc/metadata"
)

const (
        unaryOutgoingCallSpanName = "grpc.unary_outgoing_call"
)

func StartGRPCUnaryCallSegment(ctx context.Context, svcInfo ExternalServiceInfo, fullMethod string) (context.Context, func(error)) <span class="cov0" title="0">{
        attrs := []attribute.KeyValue{
                semconv.RPCSystemGRPC,
                semconv.ServerAddress(svcInfo.Hostname + ":" + svcInfo.Port),
        }

        if svc, m := extractFullMethod(fullMethod); m != "" </span><span class="cov0" title="0">{
                attrs = append(attrs,
                        semconv.RPCService(svc),
                        semconv.RPCMethod(m),
                )
        }</span>

        <span class="cov0" title="0">ctx, span := getTracer().Start(ctx, unaryOutgoingCallSpanName, trace.WithSpanKind(trace.SpanKindClient),
                trace.WithAttributes(attrs...),
        )

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                md = metadata.MD{}
        }</span> else<span class="cov0" title="0"> {
                md = md.Copy() // we have to copy the metadata because it's not safe to modify
        }</span>

        <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
        propagator.Inject(ctx, mdCarrier(md))
        ctx = metadata.NewOutgoingContext(ctx, md)
        // ? Baggage

        ctx = injectOutgoingTracingInfo(ctx, span.SpanContext())

        return ctx, func(err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, err.Error())
                        span.RecordError(err, trace.WithStackTrace(true))
                }</span>

                <span class="cov0" title="0">span.End()</span>
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package monitoring

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel/codes"
        semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
        "go.opentelemetry.io/otel/trace"
)

// StartVaultSegment starts a trace.Span with vault information
func StartVaultSegment(ctx context.Context, info ExternalServiceInfo, operation string) func(error) <span class="cov0" title="0">{
        opts := []trace.SpanStartOption{
                trace.WithSpanKind(trace.SpanKindClient),
                trace.WithAttributes(
                        semconv.ServerAddress(info.Hostname),
                ),
        }

        _, span := getTracer().Start(ctx, fmt.Sprintf("vault.%s", operation), opts...)

        return func(err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, err.Error())
                        span.RecordError(err, trace.WithStackTrace(true))
                }</span>

                <span class="cov0" title="0">span.End()</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package monitoring

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

const (
        traceIDKey         = "trace_id"
        spanIDKey          = "span_id"
        outgoingTraceIDKey = "outgoing_trace_id"
        outgoingSpanIDKey  = "outgoing_span_id"
)

// InjectField injects a field to Logger and trace.Span in context
func InjectField[T any](ctx context.Context, key string, value T) context.Context <span class="cov0" title="0">{
        trace.SpanFromContext(ctx).SetAttributes(attribute.String(key, fmt.Sprintf("%v", value)))
        return SetInContext(ctx, FromContext(ctx).With(Field(key, value)))
}</span>

func InjectFields(ctx context.Context, fields map[string]string) context.Context <span class="cov0" title="0">{
        attrs := make([]attribute.KeyValue, 0, len(fields))
        logFields := make([]LogField, 0, len(fields))
        for k, v := range fields </span><span class="cov0" title="0">{
                attrs = append(attrs, attribute.String(k, v))
                logFields = append(logFields, Field(k, v))
        }</span>

        <span class="cov0" title="0">trace.SpanFromContext(ctx).SetAttributes(attrs...)
        return SetInContext(ctx, FromContext(ctx).With(logFields...))</span>
}

func injectTracingInfo(ctx context.Context, spanCtx trace.SpanContext) context.Context <span class="cov8" title="1">{
        return SetInContext(ctx, FromContext(ctx).
                With(
                        Field(traceIDKey, spanCtx.TraceID().String()),
                        Field(spanIDKey, spanCtx.SpanID().String()),
                ),
        )
}</span>

func injectOutgoingTracingInfo(ctx context.Context, spanCtx trace.SpanContext) context.Context <span class="cov0" title="0">{
        return SetInContext(ctx, FromContext(ctx).
                With(
                        Field(outgoingTraceIDKey, spanCtx.TraceID().String()),
                        Field(outgoingSpanIDKey, spanCtx.SpanID().String()),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package monitoring

import (
        "fmt"

        "go.opentelemetry.io/otel/attribute"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type LogField zap.Field

func (l LogField) toAttribute() attribute.KeyValue <span class="cov0" title="0">{
        switch l.Type </span>{
        case zapcore.StringType:<span class="cov0" title="0">
                return attribute.String(l.Key, l.String)</span>
        case zapcore.Int64Type:<span class="cov0" title="0">
                return attribute.Int64(l.Key, l.Integer)</span>
        case zapcore.ByteStringType:<span class="cov0" title="0">
                return attribute.String(l.Key, string(l.Interface.([]byte)))</span>
        case zapcore.BoolType:<span class="cov0" title="0">
                return attribute.Bool(l.Key, l.Interface.(bool))</span>
        default:<span class="cov0" title="0">
                if l.Interface != nil </span><span class="cov0" title="0">{
                        return attribute.String(l.Key, fmt.Sprint(l.Interface))
                }</span>

                <span class="cov0" title="0">if l.Integer != 0 </span><span class="cov0" title="0">{
                        return attribute.Int64(l.Key, l.Integer)
                }</span>

                <span class="cov0" title="0">if l.String != "" </span><span class="cov0" title="0">{
                        return attribute.String(l.Key, l.String)
                }</span>

                <span class="cov0" title="0">return attribute.KeyValue{}</span>
        }
}

func Field[T any](name string, value T) LogField <span class="cov8" title="1">{
        switch v := interface{}(value).(type) </span>{
        case string:<span class="cov8" title="1">
                return LogField(zap.String(name, v))</span>
        case []string:<span class="cov0" title="0">
                return LogField(zap.Strings(name, v))</span>
        case int:<span class="cov0" title="0">
                return LogField(zap.Int(name, v))</span>
        case []byte:<span class="cov0" title="0">
                return LogField(zap.ByteString(name, v))</span>
        case bool:<span class="cov0" title="0">
                return LogField(zap.Bool(name, v))</span>
        default:<span class="cov0" title="0">
                return LogField(zap.Any(name, v))</span>
        }
}

func toZapField(f LogField) zap.Field <span class="cov8" title="1">{
        return zap.Field(f)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package monitoring

import (
        "fmt"

        "go.uber.org/zap"
)

type Logger struct {
        zapLogger *zap.Logger
}

func (l *Logger) With(fields ...LogField) *Logger <span class="cov8" title="1">{
        zapFields := make([]zap.Field, len(fields))
        for idx, field := range fields </span><span class="cov8" title="1">{
                zapFields[idx] = toZapField(field)
        }</span>

        <span class="cov8" title="1">return &amp;Logger{
                zapLogger: l.zapLogger.With(zapFields...),
        }</span>
}

// WithLazy adds log fields lazily, where the field values are not computed
// when added, but are calculated when the log is written to output
func (l *Logger) WithLazy(fields ...LogField) *Logger <span class="cov0" title="0">{
        zapFields := make([]zap.Field, len(fields))
        for idx, field := range fields </span><span class="cov0" title="0">{
                zapFields[idx] = toZapField(field)
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                zapLogger: l.zapLogger.WithLazy(zapFields...),
        }</span>
}

func (l *Logger) Infof(msg string, args ...any) <span class="cov8" title="1">{
        l.zapLogger.Info(fmt.Sprintf(msg, args...))
}</span>

func (l *Logger) Errorf(err error, msg string, args ...any) <span class="cov8" title="1">{
        l.zapLogger.Error(fmt.Sprintf(msg, args...), zap.Error(err))

        // TODO: Log to sentry
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package monitoring

import (
        "strings"

        "go.opentelemetry.io/otel/propagation"
        "google.golang.org/grpc/metadata"
)

// mdCarrier enabling TraceContext propagation via gRPC metadata
type mdCarrier metadata.MD

// Ensure mdCarrier implement TextMapCarrier interface
var _ propagation.TextMapCarrier = (*mdCarrier)(nil)

func (mdc mdCarrier) Get(key string) string <span class="cov8" title="1">{
        if vals := mdc[key]; len(vals) &gt; 0 </span><span class="cov8" title="1">{
                return vals[0]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (mdc mdCarrier) Set(key string, value string) <span class="cov0" title="0">{
        k := strings.ToLower(key) // as per google.golang.org/grpc/metadata/metadata.go
        mdc[k] = append(mdc[k], value)
}</span>

func (mdc mdCarrier) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(mdc))
        for k := range mdc </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>

        <span class="cov0" title="0">return keys</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package monitoring

import mock "github.com/stretchr/testify/mock"

// MockOption is an autogenerated mock type for the Option type
type MockOption struct {
        mock.Mock
}

// Execute provides a mock function with given fields: _a0
func (_m *MockOption) Execute(_a0 *Logger) <span class="cov0" title="0">{
        _m.Called(_a0)
}</span>

// NewMockOption creates a new instance of MockOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOption(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockOption <span class="cov0" title="0">{
        mock := &amp;MockOption{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package monitoring

import (
        "io"
        "os"

        "go.uber.org/zap"
)

func NewLogger(opts ...Option) *Logger <span class="cov0" title="0">{
        return NewLoggerWithWriter(os.Stdout, opts...)
}</span>

func NewLoggerWithWriter(w io.Writer, opts ...Option) *Logger <span class="cov8" title="1">{
        l := &amp;Logger{
                zapLogger: zap.New(newZapCore(w)),
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(l)
        }</span>

        <span class="cov8" title="1">return l</span>
}

func NewNoopLogger() *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                zapLogger: zap.NewNop(),
        }
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package monitoring

import (
        "go.uber.org/zap"
)

type Option func(*Logger)

func WithFields(fields ...LogField) Option <span class="cov8" title="1">{
        return func(l *Logger) </span><span class="cov8" title="1">{
                zapFields := make([]zap.Field, len(fields))
                for idx, f := range fields </span><span class="cov8" title="1">{
                        zapFields[idx] = toZapField(f)
                }</span>

                <span class="cov8" title="1">l.zapLogger = l.zapLogger.With(zapFields...)</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package otel

// TransportType represents OpenTelemetry exporter transport type
type TransportType string

const (
        TransportGRPC TransportType = "grpc"
        TransportHTTP TransportType = "http"
)

func (t TransportType) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

func (t TransportType) IsValid() bool <span class="cov0" title="0">{
        return t == TransportGRPC || t == TransportHTTP
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package otel

import (
        "context"
        "crypto/tls"
        "fmt"

        pkgerrors "github.com/pkg/errors"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
)

func newGRPCExporter(
        ctx context.Context,
        addr string,
        useTLS bool,
        tlsConfig *tls.Config,
) (*otlptrace.Exporter, error) <span class="cov0" title="0">{
        creds := insecure.NewCredentials()
        if useTLS </span><span class="cov0" title="0">{
                creds = credentials.NewTLS(tlsConfig)
        }</span>

        <span class="cov0" title="0">conn, err := grpc.NewClient(addr, grpc.WithTransportCredentials(creds))
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, "create grpc client")
        }</span>

        <span class="cov0" title="0">exporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, "create exporter")
        }</span>

        <span class="cov0" title="0">return exporter, nil</span>
}

func newHTTPExporter(
        ctx context.Context,
        addr string,
        useTLS bool,
        tlsConfig *tls.Config,
) (*otlptrace.Exporter, error) <span class="cov0" title="0">{
        opts := []otlptracehttp.Option{
                otlptracehttp.WithEndpoint(addr),
                otlptracehttp.WithInsecure(),
        }

        if useTLS </span><span class="cov0" title="0">{
                opts = append(opts, otlptracehttp.WithTLSClientConfig(tlsConfig))
        }</span>

        <span class="cov0" title="0">exporter, err := otlptracehttp.New(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, "create exporter")
        }</span>

        <span class="cov0" title="0">return exporter, nil</span>
}

func createExporter(ctx context.Context, cfg config) (*otlptrace.Exporter, error) <span class="cov0" title="0">{
        switch cfg.TransportType </span>{
        case TransportHTTP:<span class="cov0" title="0">
                return newHTTPExporter(ctx, cfg.ExporterURL, cfg.UseTLS, cfg.TLSConfig)</span>
        case TransportGRPC:<span class="cov0" title="0">
                return newGRPCExporter(ctx, cfg.ExporterURL, cfg.UseTLS, cfg.TLSConfig)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown transport type: %s", cfg.TransportType)</span>
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package otel

import mock "github.com/stretchr/testify/mock"

// MockExporterOption is an autogenerated mock type for the ExporterOption type
type MockExporterOption struct {
        mock.Mock
}

// Execute provides a mock function with given fields: _a0
func (_m *MockExporterOption) Execute(_a0 *config) <span class="cov0" title="0">{
        _m.Called(_a0)
}</span>

// NewMockExporterOption creates a new instance of MockExporterOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExporterOption(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockExporterOption <span class="cov0" title="0">{
        mock := &amp;MockExporterOption{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package otel

import (
        "context"
        "crypto/tls"
        "fmt"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
)

// config holds the configuration for setting up OpenTelemetry components.
type config struct {
        ExporterURL   string               // URL of the OTLP exporter
        TransportType TransportType        // Transport type: HTTP or gRPC
        UseTLS        bool                 // Whether to use TLS
        TLSConfig     *tls.Config          // TLS configuration for secure transport
        ExtraAttrs    []attribute.KeyValue // Additional resource attributes
}

func defaultConfig(url string) config <span class="cov0" title="0">{
        return config{
                ExporterURL:   url,
                TransportType: TransportGRPC,
                UseTLS:        false,
        }
}</span>

func Setup(ctx context.Context, url string, opts ...ExporterOption) error <span class="cov0" title="0">{
        cfg := defaultConfig(url)
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;cfg)
        }</span>

        <span class="cov0" title="0">if err := cfg.validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">exporter, err := createExporter(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rsc, err := buildResource(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build resource error: %w", err)
        }</span>

        // Configure the trace provider
        <span class="cov0" title="0">tracerProvider := sdktrace.NewTracerProvider(
                sdktrace.WithSampler(sdktrace.AlwaysSample()),
                sdktrace.WithResource(rsc),
                sdktrace.WithSpanProcessor(sdktrace.NewBatchSpanProcessor(
                        exporter,
                        // TODO: Enable to limit resources
                        //                DefaultMaxQueueSize       = 2048
                        //                DefaultScheduleDelay      = 5000
                        //                DefaultExportTimeout      = 30000
                        //                DefaultMaxExportBatchSize = 512
                        //sdktrace.WithMaxExportBatchSize(),
                        //sdktrace.WithMaxQueueSize(),
                )),
        )
        otel.SetTracerProvider(tracerProvider)

        // Setup propagators for trace context and baggage
        propagators := propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{}, // Support W3C TraceContext.
                propagation.Baggage{},      // Support baggage propagation.
        )
        otel.SetTextMapPropagator(propagators)

        return nil</span>
}

func (cfg config) validate() error <span class="cov0" title="0">{
        if cfg.ExporterURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("exporter URL cannot be empty")
        }</span>

        <span class="cov0" title="0">if !cfg.TransportType.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid transport type: %q", cfg.TransportType)
        }</span>

        <span class="cov0" title="0">if cfg.UseTLS &amp;&amp; cfg.TLSConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("TLS is enabled but TLSConfig is not provided")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildResource constructs a Resource object with the default and extra attributes.
// The resource combines default attributes with user-provided ones.
func buildResource(cfg config) (*resource.Resource, error) <span class="cov0" title="0">{
        if len(cfg.ExtraAttrs) == 0 </span><span class="cov0" title="0">{
                return resource.Default(), nil
        }</span>

        <span class="cov0" title="0">return resource.Merge(
                resource.Default(),
                resource.NewWithAttributes(
                        semconv.SchemaURL,
                        cfg.ExtraAttrs...,
                ),
        )</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package otel

import (
        "crypto/tls"

        "go.opentelemetry.io/otel/attribute"
)

type ExporterOption func(*config)

// WithTransportType is option to specify the Exporter transport protocol
// Supported HTTP and gRPC (default)
func WithTransportType(t TransportType) ExporterOption <span class="cov0" title="0">{
        return func(cfg *config) </span><span class="cov0" title="0">{
                cfg.TransportType = t
        }</span>
}

// WithTLS is option to enable TLS for the exporter
func WithTLS(tlsConfig *tls.Config) ExporterOption <span class="cov0" title="0">{
        return func(cfg *config) </span><span class="cov0" title="0">{
                cfg.UseTLS = true
                cfg.TLSConfig = tlsConfig
        }</span>
}

// WithAttributes is option to add additional attributes to the resource metadata
func WithAttributes(attrs map[string]string) ExporterOption <span class="cov0" title="0">{
        return func(cfg *config) </span><span class="cov0" title="0">{
                resourceAttrs := make([]attribute.KeyValue, len(attrs))
                for k, v := range attrs </span><span class="cov0" title="0">{
                        resourceAttrs = append(resourceAttrs, attribute.String(k, v))
                }</span>

                <span class="cov0" title="0">cfg.ExtraAttrs = resourceAttrs</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package monitoring

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "testing"

        "github.com/stretchr/testify/require"
        "go.opentelemetry.io/otel/propagation"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        "go.opentelemetry.io/otel/sdk/trace/tracetest"
        "go.opentelemetry.io/otel/trace"
)

type MonitorTest struct {
        logBuffer    *bytes.Buffer
        logger       *Logger
        spanExporter *tracetest.InMemoryExporter
        tp           trace.TracerProvider
        propagator   propagation.TextMapPropagator
}

func NewMonitorTest() (MonitorTest, func()) <span class="cov8" title="1">{
        logBuffer := new(bytes.Buffer)
        logger := NewLoggerWithWriter(logBuffer)

        exporter := tracetest.NewInMemoryExporter()

        m := MonitorTest{
                logBuffer:    logBuffer,
                logger:       logger,
                spanExporter: exporter,
                tp: sdktrace.NewTracerProvider(
                        sdktrace.WithSampler(sdktrace.AlwaysSample()),
                        sdktrace.WithSyncer(exporter),
                        sdktrace.WithIDGenerator(&amp;staticIDGenerator{}),
                ),
                propagator: propagation.NewCompositeTextMapPropagator(
                        propagation.TraceContext{}, // Support W3C TraceContext.
                        propagation.Baggage{},      // Support baggage propagation.
                ),
        }

        originGetTracer := getTracer
        originGetPropagator := getTextMapPropagator

        // Override getTracer, getPropagator for testing
        getTracer = m.GetTracer
        getTextMapPropagator = m.GetPropagator

        return m, func() </span><span class="cov8" title="1">{
                getTracer = originGetTracer
                getTextMapPropagator = originGetPropagator
        }</span>
}

func (m MonitorTest) Context() context.Context <span class="cov8" title="1">{
        return SetInContext(context.Background(), m.logger)
}</span>

func (m MonitorTest) GetLogger() *Logger <span class="cov8" title="1">{
        return m.logger
}</span>

func (m MonitorTest) GetLogs(t *testing.T) []map[string]interface{} <span class="cov8" title="1">{
        t.Helper()
        var logs []map[string]interface{}

        lines := bytes.Split(m.logBuffer.Bytes(), []byte("\n")) // \n is end of line
        for _, line := range lines </span><span class="cov8" title="1">{
                if len(line) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var msg map[string]interface{}
                require.NoError(t, json.Unmarshal(line, &amp;msg))
                logs = append(logs, msg)</span>
        }

        <span class="cov8" title="1">return logs</span>
}

func (m MonitorTest) GetTracer() trace.Tracer <span class="cov8" title="1">{
        return m.tp.Tracer(tracerName)
}</span>

func (m MonitorTest) GetPropagator() propagation.TextMapPropagator <span class="cov8" title="1">{
        return m.propagator
}</span>

func (m MonitorTest) GetSpans() tracetest.SpanStubs <span class="cov8" title="1">{
        return m.spanExporter.GetSpans()
}</span>

// staticIDGenerator supports generate static trace_id &amp; span_id for unit test
type staticIDGenerator struct{}

var _ sdktrace.IDGenerator = (*staticIDGenerator)(nil)

func (gen staticIDGenerator) NewIDs(ctx context.Context) (trace.TraceID, trace.SpanID) <span class="cov0" title="0">{
        traceIDHex := fmt.Sprintf("%032x", 1)
        traceID, _ := trace.TraceIDFromHex(traceIDHex)

        spanID := gen.NewSpanID(ctx, traceID)

        return traceID, spanID
}</span>

func (gen staticIDGenerator) NewSpanID(ctx context.Context, traceID trace.TraceID) trace.SpanID <span class="cov8" title="1">{
        spanIDHex := fmt.Sprintf("%016x", 1)
        spanID, _ := trace.SpanIDFromHex(spanIDHex)
        return spanID
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package monitoring

import (
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
)

const (
        tracerName = "gitlab.com/bizgroup2/lightning/monitoring"
)

var (
        // getTracer creates tracer by global TracerProvider
        getTracer = func() trace.Tracer <span class="cov0" title="0">{
                return otel.Tracer(tracerName)
        }</span>

        // getTextMapPropagator returns global TextMapPropagator configs
        getTextMapPropagator = func() propagation.TextMapPropagator <span class="cov0" title="0">{
                return otel.GetTextMapPropagator()
        }</span>
)
</pre>
		
		<pre class="file" id="file81" style="display: none">package monitoring

import (
        "io"

        "go.uber.org/zap/zapcore"
)

func newZapCore(w io.Writer) zapcore.Core <span class="cov8" title="1">{
        return zapcore.NewCore(
                zapcore.NewJSONEncoder(newEncoderConfig()),
                zapcore.AddSync(w),
                zapcore.InfoLevel,
        )
}</span>

func newEncoderConfig() zapcore.EncoderConfig <span class="cov8" title="1">{
        return zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
                EncodeTime:     zapcore.EpochTimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package postgres

import (
        "database/sql"

        _ "github.com/jackc/pgx/v4/stdlib"
        pkgerrors "github.com/pkg/errors"
)

const (
        defaultMaxIdleConn = 2
        defaultMaxOpenConn = 20
)

// Connect returns the singleton instance of the database
func Connect(url string) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("pgx", url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, "opening postgres connection")
        }</span>

        <span class="cov0" title="0">db.SetMaxIdleConns(defaultMaxIdleConn)
        db.SetMaxOpenConns(defaultMaxOpenConn)

        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockBeginner is an autogenerated mock type for the Beginner type
type MockBeginner struct {
        mock.Mock
}

// Begin provides a mock function with given fields:
func (_m *MockBeginner) Begin() (*sql.Tx, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Begin")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Tx
        var r1 error
        if rf, ok := ret.Get(0).(func() (*sql.Tx, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() *sql.Tx); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Tx)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMockBeginner creates a new instance of MockBeginner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBeginner(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockBeginner <span class="cov0" title="0">{
        mock := &amp;MockBeginner{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        context "context"
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockContextBeginner is an autogenerated mock type for the ContextBeginner type
type MockContextBeginner struct {
        mock.Mock
}

// BeginTx provides a mock function with given fields: _a0, _a1
func (_m *MockContextBeginner) BeginTx(_a0 context.Context, _a1 *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Tx
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *sql.TxOptions) (*sql.Tx, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *sql.TxOptions) *sql.Tx); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Tx)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *sql.TxOptions) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Exec provides a mock function with given fields: query, args
func (_m *MockContextBeginner) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ExecContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextBeginner) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExecContext")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Prepare provides a mock function with given fields: query
func (_m *MockContextBeginner) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// PrepareContext provides a mock function with given fields: ctx, query
func (_m *MockContextBeginner) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PrepareContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: query, args
func (_m *MockContextBeginner) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextBeginner) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: query, args
func (_m *MockContextBeginner) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// QueryRowContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextBeginner) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRowContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewMockContextBeginner creates a new instance of MockContextBeginner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockContextBeginner(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockContextBeginner <span class="cov0" title="0">{
        mock := &amp;MockContextBeginner{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        context "context"
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockContextExecutor is an autogenerated mock type for the ContextExecutor type
type MockContextExecutor struct {
        mock.Mock
}

// Exec provides a mock function with given fields: query, args
func (_m *MockContextExecutor) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ExecContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextExecutor) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExecContext")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Prepare provides a mock function with given fields: query
func (_m *MockContextExecutor) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// PrepareContext provides a mock function with given fields: ctx, query
func (_m *MockContextExecutor) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PrepareContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: query, args
func (_m *MockContextExecutor) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextExecutor) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: query, args
func (_m *MockContextExecutor) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// QueryRowContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextExecutor) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRowContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewMockContextExecutor creates a new instance of MockContextExecutor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockContextExecutor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockContextExecutor <span class="cov0" title="0">{
        mock := &amp;MockContextExecutor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        context "context"
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockContextTransactor is an autogenerated mock type for the ContextTransactor type
type MockContextTransactor struct {
        mock.Mock
}

// Commit provides a mock function with given fields:
func (_m *MockContextTransactor) Commit() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Commit")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Exec provides a mock function with given fields: query, args
func (_m *MockContextTransactor) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ExecContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextTransactor) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExecContext")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Prepare provides a mock function with given fields: query
func (_m *MockContextTransactor) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// PrepareContext provides a mock function with given fields: ctx, query
func (_m *MockContextTransactor) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PrepareContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: query, args
func (_m *MockContextTransactor) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextTransactor) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: query, args
func (_m *MockContextTransactor) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// QueryRowContext provides a mock function with given fields: ctx, query, args
func (_m *MockContextTransactor) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRowContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// Rollback provides a mock function with given fields:
func (_m *MockContextTransactor) Rollback() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Rollback")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockContextTransactor creates a new instance of MockContextTransactor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockContextTransactor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockContextTransactor <span class="cov0" title="0">{
        mock := &amp;MockContextTransactor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockExecutor is an autogenerated mock type for the Executor type
type MockExecutor struct {
        mock.Mock
}

// Exec provides a mock function with given fields: query, args
func (_m *MockExecutor) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Prepare provides a mock function with given fields: query
func (_m *MockExecutor) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: query, args
func (_m *MockExecutor) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: query, args
func (_m *MockExecutor) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewMockExecutor creates a new instance of MockExecutor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExecutor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockExecutor <span class="cov0" title="0">{
        mock := &amp;MockExecutor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Code generated by mockery v2.49.1. DO NOT EDIT.

package postgres

import (
        sql "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// MockTransactor is an autogenerated mock type for the Transactor type
type MockTransactor struct {
        mock.Mock
}

// Commit provides a mock function with given fields:
func (_m *MockTransactor) Commit() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Commit")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Exec provides a mock function with given fields: query, args
func (_m *MockTransactor) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Prepare provides a mock function with given fields: query
func (_m *MockTransactor) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _m.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return rf(query)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: query, args
func (_m *MockTransactor) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: query, args
func (_m *MockTransactor) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// Rollback provides a mock function with given fields:
func (_m *MockTransactor) Rollback() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Rollback")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewMockTransactor creates a new instance of MockTransactor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTransactor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockTransactor <span class="cov0" title="0">{
        mock := &amp;MockTransactor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package lightning

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type Router interface {
        Use(middleware ...func(ctx Context))

        Handle(method string, relativePath string, handler ErrHandlerFunc)

        Get(relativePath string, handler ErrHandlerFunc)

        Post(relativePath string, handler ErrHandlerFunc)

        Put(relativePath string, handler ErrHandlerFunc)

        Patch(relativePath string, handler ErrHandlerFunc)

        Delete(relativePath string, handler ErrHandlerFunc)

        Group(relativePath string, routerFunc func(Router))
}

type router struct {
        ginRouter gin.IRouter
}

func NewRouter() (Router, http.Handler) <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        engine := gin.New()

        return router{
                ginRouter: engine,
        }, engine.Handler()
}</span>

func (rtr router) Use(middleware ...func(ctx Context)) <span class="cov8" title="1">{
        handlers := make([]gin.HandlerFunc, len(middleware))
        for idx, m := range middleware </span><span class="cov8" title="1">{
                handlers[idx] = func(ctx *gin.Context) </span><span class="cov8" title="1">{
                        m(lightningContext{Context: ctx})
                }</span>
        }

        <span class="cov8" title="1">rtr.ginRouter.Use(handlers...)</span>
}

func (rtr router) Handle(method string, relativePath string, handler ErrHandlerFunc) <span class="cov8" title="1">{
        rtr.ginRouter.Handle(method, relativePath, handleHttpError(handler))
}</span>

func (rtr router) Get(relativePath string, handler ErrHandlerFunc) <span class="cov0" title="0">{
        rtr.Handle(http.MethodGet, relativePath, handler)
}</span>

func (rtr router) Post(relativePath string, handler ErrHandlerFunc) <span class="cov0" title="0">{
        rtr.Handle(http.MethodPost, relativePath, handler)
}</span>

func (rtr router) Put(relativePath string, handler ErrHandlerFunc) <span class="cov0" title="0">{
        rtr.Handle(http.MethodPut, relativePath, handler)
}</span>

func (rtr router) Patch(relativePath string, handler ErrHandlerFunc) <span class="cov0" title="0">{
        rtr.Handle(http.MethodPatch, relativePath, handler)
}</span>

func (rtr router) Delete(relativePath string, handler ErrHandlerFunc) <span class="cov0" title="0">{
        rtr.Handle(http.MethodDelete, relativePath, handler)
}</span>

func (rtr router) Group(relativePath string, routerFunc func(Router)) <span class="cov0" title="0">{
        routerGroup := rtr.ginRouter.Group(relativePath)
        wrappedRoute := router{
                ginRouter: routerGroup,
        }

        routerFunc(wrappedRoute)
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package lightning

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os/signal"
        "syscall"
        "time"

        pkgerrors "github.com/pkg/errors"
)

type Server struct {
        httpServer    *http.Server
        withTLS       bool
        certFile      string
        keyFile       string
        shutdownGrace time.Duration
}

// NewHttpServer creates new http server
func NewHttpServer(ctx context.Context, addr string, setupRouteFunc func(Router), opts ...func(*Server)) Server <span class="cov0" title="0">{
        // Create new router
        r, hdl := NewRouter()
        r.Use(rootMiddleware(ctx))

        // Setup routes
        setupRouteFunc(r)

        // Setup server
        srv := Server{
                httpServer: &amp;http.Server{
                        Addr:    addr,
                        Handler: hdl,
                },
        }

        // Configures server
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;srv)
        }</span>

        <span class="cov0" title="0">return srv</span>
}

func (srv *Server) Run() error <span class="cov0" title="0">{
        // kill (no param) default send syscall.SIGTERM
        // kill -2 is syscall.SIGINT
        // kill -9 is syscall. SIGKILL but can"t be catch, so don't need add it
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        return srv.start(ctx)
}</span>

func (srv *Server) start(ctx context.Context) error <span class="cov0" title="0">{
        startupErr := make(chan error)

        // Start server
        go func() </span><span class="cov0" title="0">{
                fmt.Printf("web server started; listening at %s\n", srv.httpServer.Addr)
                defer fmt.Println("web server shutdown")

                var err error
                if srv.withTLS </span><span class="cov0" title="0">{
                        err = srv.httpServer.ListenAndServeTLS(srv.certFile, srv.keyFile)
                }</span> else<span class="cov0" title="0"> {
                        err = srv.httpServer.ListenAndServe()
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        startupErr &lt;- err
                }</span>
        }()

        // Blocking main and waiting for shutdown.
        <span class="cov0" title="0">select </span>{
        case err := &lt;-startupErr:<span class="cov0" title="0">
                // ListenAndServe will always return a non-nil error
                if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return pkgerrors.Wrap(err, "http server stopped")
                }</span>
                <span class="cov0" title="0">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return srv.stop()</span>
        }
}

func (srv *Server) stop() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), srv.shutdownGrace)
        defer cancel()

        fmt.Printf("attempting to shutdown gracefully\n")
        defer fmt.Println("server shutdown successfully")

        if err := srv.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("failed to shutdown gracefully: %v, force shutdown\n", err)

                if err = srv.httpServer.Close(); err != nil </span><span class="cov0" title="0">{
                        return pkgerrors.Wrap(err, "force shutdown")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package snowflake

import (
        "fmt"

        pkgerrors "github.com/pkg/errors"
)

// Generate will produce a new snowflake unique id
// The lifetime is (174 years). Ref - https://github.com/sony/sonyflake/blob/848d664ceea4c980874f2135c85c42409c530b1f/sonyflake_test.go#L179
func (g *Generator) Generate() (int64, error) <span class="cov8" title="1">{
        id, err := g.flake.NextID()
        if err != nil </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithMessage(err, "snowflake ID generation failed")
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov0" title="0">{
                return 0, pkgerrors.WithStack(fmt.Errorf("snowflake ID is invalid: %d", id))
        }</span>

        <span class="cov8" title="1">return int64(id), nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package snowflake

import (
        "time"

        "github.com/sony/sonyflake"
)

// Generator generates the snowflake ID
type Generator struct {
        flake *sonyflake.Sonyflake
}

// New returns a new instance of Generator
func New(opts ...Option) (*Generator, error) <span class="cov8" title="1">{
        s := sonyflake.Settings{
                StartTime: time.Date(2021, 1, 1, 0, 0, 0, 0, time.UTC),
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(&amp;s); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;Generator{
                flake: sonyflake.NewSonyflake(s),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package snowflake

import (
        "fmt"
        "time"

        pkgerrors "github.com/pkg/errors"
        "github.com/sony/sonyflake"
)

// Option is an optional config used to modify the snowflake behaviour
type Option func(s *sonyflake.Settings) error

// StartTime defines the time from which the snowflake should be generated
func StartTime(t time.Time) Option <span class="cov8" title="1">{
        return func(s *sonyflake.Settings) error </span><span class="cov8" title="1">{
                if t.IsZero() || t.After(time.Now()) </span><span class="cov8" title="1">{
                        return pkgerrors.WithStack(fmt.Errorf("invalid start time provided: %s", t))
                }</span>

                <span class="cov8" title="1">s.StartTime = t.UTC()
                return nil</span>
        }
}

// MachineID defines the id of the machine from which the snowflake should be generated
func MachineID(id uint16) Option <span class="cov8" title="1">{
        return func(s *sonyflake.Settings) error </span><span class="cov8" title="1">{
                if id == 0 </span><span class="cov8" title="1">{
                        return pkgerrors.WithStack(fmt.Errorf("invalid machine ID provided: %d", id))
                }</span>
                <span class="cov8" title="1">s.MachineID = func() (uint16, error) </span><span class="cov8" title="1">{
                        return id, nil
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package lightning

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func NewRouterForTest(w http.ResponseWriter) (Router, Context, func()) <span class="cov8" title="1">{
        gin.SetMode(gin.TestMode)
        route := gin.New()
        rtr := router{
                ginRouter: route,
        }

        ginCtx := gin.CreateTestContextOnly(w, route)
        ctx := lightningContext{
                Context: ginCtx,
        }

        return rtr, ctx, func() </span><span class="cov8" title="1">{
                route.HandleContext(ginCtx)
        }</span>
}

func NewTestRoute(w http.ResponseWriter) (Router, func(func(Context))) <span class="cov0" title="0">{
        gin.SetMode(gin.TestMode)
        route := gin.New()
        rtr := router{
                ginRouter: route,
        }

        return rtr, func(cb func(Context)) </span><span class="cov0" title="0">{
                ginCtx := gin.CreateTestContextOnly(w, route)
                cb(lightningContext{
                        Context: ginCtx,
                })

                route.HandleContext(ginCtx)
        }</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package vault

func (client *Client) SetToken(token string) error <span class="cov0" title="0">{
        if err := client.vaultClient.SetToken(token); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package vault

import (
        "context"

        pkgerrors "github.com/pkg/errors"

        "github.com/hashicorp/vault-client-go"

        "github.com/viebiz/lit/monitoring"
)

const (
        secretMountPath = "secret"
)

func (client *Client) GetSecrets(ctx context.Context, path string) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        segEnd := monitoring.StartVaultSegment(ctx, client.info, "KvV2Read")
        defer func() </span><span class="cov0" title="0">{
                segEnd(err)
        }</span>()

        <span class="cov0" title="0">resp, err := client.vaultClient.Secrets.KvV2Read(ctx, path, vault.WithMountPath(secretMountPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return resp.Data.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package vault

import (
        "net/http"

        pkgerrors "github.com/pkg/errors"

        "github.com/hashicorp/vault-client-go"

        "github.com/viebiz/lit/monitoring"
)

type Client struct {
        vaultClient *vault.Client
        info        monitoring.ExternalServiceInfo
}

// NewClient creates a new Vault Client to access the secret vault
func NewClient(address string, httpClient *http.Client) (*Client, error) <span class="cov0" title="0">{
        vc, err := vault.New(
                vault.WithAddress(address),
                vault.WithHTTPClient(httpClient),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                vaultClient: vc,
                info:        monitoring.NewExternalServiceInfo(address),
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
